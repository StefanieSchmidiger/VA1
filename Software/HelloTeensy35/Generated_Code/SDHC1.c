/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : SDHC1.c
**     Project     : HelloTeensy35
**     Processor   : MK64FX512VLQ12
**     Component   : SDHC_LDD
**     Version     : Component 00.001, Driver 01.04, CPU db: 3.00.000
**     Repository  : Kinetis
**     Compiler    : GNU C Compiler
**     Date/Time   : 2017-10-04, 12:03, # CodeGen: 17
**     Abstract    :
**          This component implements a SD host controller driver 
**          interface. Handles control and data transfers to/from
**          SD and MMC cards.
**     Settings    :
**          Component name                                 : SDHC1
**          Device                                         : SDHC
**          Settings                                       : 
**            Interface                                    : 1-bit data mode
**            Bus clock                                    : 400 kHz
**            Data timeout exponent                        : 20
**            DMA                                          : 
**              Read watermark                             : 16
**              Write watermark                            : 16
**            Buffers                                      : 
**              Transfer buffer table size                 : 8
**          Interrupt service/event                        : Enabled
**            SDHC                                         : INT_SDHC
**            SDHC priority                                : medium priority
**          Pins                                           : 1-bit data mode
**            CLK pin                                      : ADC0_DP2/ADC1_SE6a/PTE2/LLWU_P1/SPI1_SCK/UART1_CTS_b/SDHC0_DCLK/TRACE_D2
**            CMD pin                                      : ADC0_DM2/ADC1_SE7a/PTE3/SPI1_SIN/UART1_RTS_b/SDHC0_CMD/TRACE_D1/SPI1_SOUT
**            Data                                         : 
**              DAT0 pin                                   : ADC1_SE5a/PTE1/LLWU_P0/SPI1_SOUT/UART1_RX/SDHC0_D0/TRACE_D3/I2C1_SCL/SPI1_SIN
**              DAT1                                       : Disabled
**              DAT2                                       : Disabled
**              DAT3                                       : Disabled
**          Initialization                                 : 
**            Enable device                                : yes
**            Auto initialization                          : no
**            Event mask                                   : 
**              OnCardInserted                             : Enabled
**              OnCardRemoved                              : Enabled
**              OnFinished                                 : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init           - LDD_TDeviceData* SDHC1_Init(LDD_TUserData *UserDataPtr);
**         DetectCards    - LDD_TError SDHC1_DetectCards(LDD_TDeviceData *DeviceDataPtr);
**         SelectCard     - LDD_TError SDHC1_SelectCard(LDD_TDeviceData *DeviceDataPtr, uint8_t Id);
**         GetCardInfo    - LDD_TError SDHC1_GetCardInfo(LDD_TDeviceData *DeviceDataPtr,...
**         TransferBlocks - LDD_TError SDHC1_TransferBlocks(LDD_TDeviceData *DeviceDataPtr,...
**         GetStatus      - LDD_SDHC_TStatus SDHC1_GetStatus(LDD_TDeviceData *DeviceDataPtr);
**         GetError       - LDD_SDHC_TError SDHC1_GetError(LDD_TDeviceData *DeviceDataPtr, uint32_t...
**
**     Copyright : 1997 - 2015 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file SDHC1.c
** @version 01.04
** @brief
**          This component implements a SD host controller driver 
**          interface. Handles control and data transfers to/from
**          SD and MMC cards.
*/         
/*!
**  @addtogroup SDHC1_module SDHC1 module documentation
**  @{
*/         

/* MODULE SDHC1 */

/*lint -save  -esym(960,10.1) -e961 Disable MISRA rule (10.1,12.1) checking. */

#include "Events.h"
#include "SDHC1.h"
/* {Default RTOS Adapter} No RTOS includes */
#include "SDHC_PDD.h"
#include "PORT_PDD.h"

#ifdef __cplusplus
extern "C" {
#endif 

/* Configuration constants */
#define SDHC1_MAX_CARD_NUMBER   1U
#define SDHC1_BUFFER_TABLE_SIZE 8U

/* Component constants */
#define SDHC1_OCR_HIGH_VOLTAGE_MASK     0x00FF8000UL
#define SDHC1_OCR_LOW_VOLTAGE_MASK      0x00000080UL
#define SDHC1_OCR_HIGH_CAPACITY_MASK    0x40000000UL
#define SDHC1_IF_COND_LOW_VOLTAGE_MASK  0x00000200UL
#define SDHC1_IF_COND_HIGH_VOLTAGE_MASK 0x00000100UL
#define SDHC1_IF_COND_CHECK_PATTERN     0x000000AAUL
#define SDHC1_VOLT_VALID_RETRY_COUNT    6500U /* Number of OCR (operation conditions register) request repetitions to give the card 1 second to power up (with 400kHz bus clock) */
#define SDHC1_NO_RESPONSE               0U
#define SDHC1_CSD_SIZE                  16U /* Card specific data register size */
#define SDHC1_EXT_CSD_SIZE              512U /* Extended card specific data register size */
#define SDHC1_SCR_SIZE                  8U /* SD card configuration register size */
#define SDHC1_SFS_SIZE                  64U /* Switch function statuses register size */
#define SDHC1_WRITE_PROTECT_MASK_SIZE   4U /* Write protection mask size */

/* Endianness correction macros */
#define SDHC1_BE_TO_NE16(x) ((uint16_t)((uint16_t)(x) >> 8) | (uint16_t)((uint16_t)(x) << 8)) /* Big endian to native endian 16-bit */
#define SDHC1_BE_TO_NE32(x) (((uint32_t)((uint32_t)(x) >> 24) & 0xFFU) | ((uint32_t)((uint32_t)(x) >> 8) & 0xFF00U) | ((uint32_t)((uint32_t)(x) << 8) & 0xFF0000U) | ((uint32_t)((uint32_t)(x) << 24) & 0xFF000000U)) /* Big endian to native endian 32-bit */
#define SDHC1_NE_TO_BE16(x) ((uint16_t)((uint16_t)(x) >> 8) | (uint16_t)((uint16_t)(x) << 8)) /* Native endian to big endian 16-bit */
#define SDHC1_NE_TO_BE32(x) (((uint32_t)((uint32_t)(x) >> 24) & 0xFFU) | ((uint32_t)((uint32_t)(x) >> 8) & 0xFF00U) | ((uint32_t)((uint32_t)(x) << 8) & 0xFF0000U) | ((uint32_t)((uint32_t)(x) << 24) & 0xFF000000U)) /* Native endian to big endian 32-bit */

/* Command arguments macros */
#define SDHC1_CMD_ARG_RCA(RCA)            (uint32_t)((uint32_t)(RCA) << 16)
#define SDHC1_SD_CMD6_ARG_MODE(Mode)      (uint32_t)((uint32_t)(Mode) << 31)
  #define SDHC1_SD_CMD6_CHECK_FUNC  0U
  #define SDHC1_SD_CMD6_SWITCH_FUNC 1U
#define SDHC1_SD_CMD6_ARG_GROUP_1(Func)   (uint32_t)((uint32_t)(Func) << 0)
  #define SDHC1_SD_CMD6_GROUP_1_HIGH_SPEED 1U
#define SDHC1_SD_CMD6_ARG_GROUP_2(Func)   (uint32_t)((uint32_t)(Func) << 4)
#define SDHC1_MMC_CMD6_ARG_ACCESS(Access) (uint32_t)((uint32_t)(Access) << 24)
  #define SDHC1_MMC_CMD6_COMMAND_SET 0U
  #define SDHC1_MMC_CMD6_SET_BITS    1U
  #define SDHC1_MMC_CMD6_CLEAR_BITS  2U
  #define SDHC1_MMC_CMD6_WRITE_BYTES 3U
#define SDHC1_MMC_CMD6_ARG_INDEX(Index)   (uint32_t)((uint32_t)(Index) << 16)
#define SDHC1_MMC_CMD6_ARG_VALUE(Value)   (uint32_t)((uint32_t)(Value) << 8)
#define SDHC1_MMC_CMD6_ARG_CMD_SET(Set)   (uint32_t)((uint32_t)(Set) << 0)

/* Response 1 status register field access macros */
#define SDHC1_R1_IS_ADDRESS_OUT_OF_RANGE(Response) ((Response)[0] & 0x80000000UL)
#define SDHC1_R1_IS_ADDRESS_MISALIGN(Response)     ((Response)[0] & 0x40000000UL)
#define SDHC1_R1_IS_BLOCK_LEN_ERROR(Response)      ((Response)[0] & 0x20000000UL)
#define SDHC1_R1_IS_ERASE_SEQ_ERROR(Response)      ((Response)[0] & 0x10000000UL)
#define SDHC1_R1_IS_ERASE_PARAM(Response)          ((Response)[0] & 0x08000000UL)
#define SDHC1_R1_IS_WP_VIOLATION(Response)         ((Response)[0] & 0x04000000UL)
#define SDHC1_R1_IS_CARD_IS_LOCKED(Response)       ((Response)[0] & 0x02000000UL)
#define SDHC1_R1_IS_LOCK_UNLOCK_FAILED(Response)   ((Response)[0] & 0x01000000UL)
#define SDHC1_R1_IS_COM_CRC_ERROR(Response)        ((Response)[0] & 0x00800000UL)
#define SDHC1_R1_IS_ILLEGAL_COMMAND(Response)      ((Response)[0] & 0x00400000UL)
#define SDHC1_R1_IS_CARD_ECC_FAILED(Response)      ((Response)[0] & 0x00200000UL)
#define SDHC1_R1_IS_CC_ERROR(Response)             ((Response)[0] & 0x00100000UL)
#define SDHC1_R1_IS_ERROR(Response)                ((Response)[0] & 0x00080000UL)
#define SDHC1_R1_MMC_IS_UNDERRUN(Response)         ((Response)[0] & 0x00040000UL)
#define SDHC1_R1_MMC_IS_OVERRUN(Response)          ((Response)[0] & 0x00020000UL)
#define SDHC1_R1_IS_CSD_OVERWRITE(Response)        ((Response)[0] & 0x00010000UL)
#define SDHC1_R1_IS_WP_ERASE_SKIP(Response)        ((Response)[0] & 0x00008000UL)
#define SDHC1_R1_SD_IS_CARD_ECC_DISABLED(Response) ((Response)[0] & 0x00004000UL)
#define SDHC1_R1_IS_ERASE_RESET(Response)          ((Response)[0] & 0x00002000UL)
#define SDHC1_R1_GET_CURRENT_STATE(Response)       (((Response)[0] & 0x00001E00UL) >> 9)
  #define SDHC1_R1_IDLE_STATE           0x00U
  #define SDHC1_R1_READY_STATE          0x01U
  #define SDHC1_R1_IDENTIFICATION_STATE 0x02U
  #define SDHC1_R1_STAND_BY_STATE       0x03U
  #define SDHC1_R1_TRANSFER_STATE       0x04U
  #define SDHC1_R1_SENDING_DATA_STATE   0x05U
  #define SDHC1_R1_RECEIVE_DATA_STATE   0x06U
  #define SDHC1_R1_PROGRAMMING_STATE    0x07U
  #define SDHC1_R1_DISCONNECT_STATE     0x08U
  #define SDHC1_R1_BUS_TEST_STATE       0x09U
  #define SDHC1_R1_SLEEP_STATE          0x0AU
#define SDHC1_R1_IS_READY_FOR_DATA(Response)       ((Response)[0] & 0x00000100UL)
#define SDHC1_R1_IS_SWITCH_ERROR(Response)         ((Response)[0] & 0x00000080UL)
#define SDHC1_R1_IS_APP_CMD(Response)              ((Response)[0] & 0x00000020UL)
#define SDHC1_R1_SD_IS_AKE_SEQ_ERROR(Response)     ((Response)[0] & 0x00000008UL)

/* Response 2 SD CSD (card specific data) v1, v2 and MMC CSD (card specific data) register field access macros */
#define SDHC1_R2_GET_CSD_STRUCTURE(Response)        (((Response)[3] & 0x00C00000UL) >> 22)
  #define SDHC1_SD_CSD_VERS_1_0         0U
  #define SDHC1_SD_CSD_VERS_2_0         1U
  #define SDHC1_MMC_CSD_VERS_1_0        0U
  #define SDHC1_MMC_CSD_VERS_1_1        1U
  #define SDHC1_MMC_CSD_VERS_1_2        2U
  #define SDHC1_MMC_CSD_VERS_IN_EXT_CSD 3U
#define SDHC1_R2_MMC_GET_SPEC_VERS(Response)        (((Response)[3] & 0x003C0000UL) >> 18)
  #define SDHC1_MMC_CSD_SPEC_VERS_1_X 0U
  #define SDHC1_MMC_CSD_SPEC_VERS_1_4 1U
  #define SDHC1_MMC_CSD_SPEC_VERS_2_X 2U
  #define SDHC1_MMC_CSD_SPEC_VERS_3_X 3U
  #define SDHC1_MMC_CSD_SPEC_VERS_4_X 4U
#define SDHC1_R2_GET_TAAC(Response)                 (((Response)[3] & 0x0000FF00UL) >> 8)
#define SDHC1_R2_GET_NSAC(Response)                 (((Response)[3] & 0x000000FFUL) >> 0)
#define SDHC1_R2_GET_TRAN_SPEED(Response)           (((Response)[2] & 0xFF000000UL) >> 24)
#define SDHC1_R2_GET_CCC(Response)                  (((Response)[2] & 0x00FFF000UL) >> 12)
#define SDHC1_R2_GET_READ_BL_LEN(Response)          (((Response)[2] & 0x00000F00UL) >> 8)
#define SDHC1_R2_GET_READ_BL_PARTIAL(Response)      (((Response)[2] & 0x00000080UL) >> 7)
#define SDHC1_R2_GET_WRITE_BLK_MISALIGN(Response)   (((Response)[2] & 0x00000040UL) >> 6)
#define SDHC1_R2_GET_READ_BLK_MISALIGN(Response)    (((Response)[2] & 0x00000020UL) >> 5)
#define SDHC1_R2_GET_DSR_IMP(Response)              (((Response)[2] & 0x00000010UL) >> 4)
/* Response 2 CSD (card specific data) v1 register field access macros */
#define SDHC1_R2_CSD_V1_GET_C_SIZE(Response)         ((((Response)[2] & 0x00000003UL) << 10) | (((Response)[1] & 0xFFC00000UL) >> 22))
#define SDHC1_R2_CSD_V1_GET_MIN_VDD_R_CURR(Response) (((Response)[1] & 0x00380000UL) >> 19)
#define SDHC1_R2_CSD_V1_GET_MAX_VDD_R_CURR(Response) (((Response)[1] & 0x00070000UL) >> 16)
#define SDHC1_R2_CSD_V1_GET_MIN_VDD_W_CURR(Response) (((Response)[1] & 0x0000E000UL) >> 13)
#define SDHC1_R2_CSD_V1_GET_MAX_VDD_W_CURR(Response) (((Response)[1] & 0x00001C00UL) >> 10)
#define SDHC1_R2_CSD_V1_GET_C_SIZE_MULT(Response)    (((Response)[1] & 0x00000380UL) >> 7)
/* Response 2 SD CSD (card specific data) v2 register field access macros */
#define SDHC1_R2_CSD_V2_GET_C_SIZE(Response)         (((Response)[1] & 0x3FFFFF00UL) >> 8)
/* Response 2 SD CSD (card specific data) register field access macros */
#define SDHC1_R2_SD_GET_ERASE_BLOCK_EN(Response)    (((Response)[1] & 0x00000040UL) >> 6)
#define SDHC1_R2_SD_GET_SECTOR_SIZE(Response)       ((((Response)[1] & 0x0000003FUL) << 1) | (((Response)[0] & 0x80000000UL) >> 31))
#define SDHC1_R2_SD_GET_WP_GRP_SIZE(Response)       (((Response)[0] & 0x1F000000UL) >> 24)
/* Response 2 MMC CSD (card specific data) register field access macros */
#define SDHC1_R2_MMC_GET_ERASE_GRP_SIZE(Response)   (((Response)[1] & 0x0000007CUL) >> 2)
#define SDHC1_R2_MMC_GET_ERASE_GRP_MULT(Response)   ((((Response)[1] & 0x00000003UL) << 3) | (((Response)[0] & 0xE0000000UL) >> 29))
#define SDHC1_R2_MMC_GET_WP_GRP_SIZE(Response)      (((Response)[0] & 0x1F000000UL) >> 24)
/* Response 2 CSD (card specific data) register field access macros */
#define SDHC1_R2_GET_WP_GRP_ENABLE(Response)        (((Response)[0] & 0x00800000UL) >> 23)
#define SDHC1_R2_GET_DEFAULT_ECC(Response)          (((Response)[0] & 0x00600000UL) >> 21)
#define SDHC1_R2_GET_R2W_FACTOR(Response)           (((Response)[0] & 0x001C0000UL) >> 18)
#define SDHC1_R2_GET_WRITE_BL_LEN(Response)         (((Response)[0] & 0x0003C000UL) >> 14)
#define SDHC1_R2_GET_WRITE_BL_PARTIAL(Response)     (((Response)[0] & 0x00002000UL) >> 13)
#define SDHC1_R2_GET_CONTENT_PROT_APP(Response)     (((Response)[0] & 0x00000100UL) >> 8)
#define SDHC1_R2_GET_FILE_FORMAT_GRP(Response)      (((Response)[0] & 0x00000080UL) >> 7)
#define SDHC1_R2_GET_COPY(Response)                 (((Response)[0] & 0x00000040UL) >> 6)
#define SDHC1_R2_GET_PERM_WRITE_PROTECT(Response)   (((Response)[0] & 0x00000020UL) >> 5)
#define SDHC1_R2_GET_TMP_WRITE_PROTECT(Response)    (((Response)[0] & 0x00000010UL) >> 4)
#define SDHC1_R2_GET_FILE_FORMAT(Response)          (((Response)[0] & 0x0000000CUL) >> 2)
#define SDHC1_R2_GET_ECC(Response)                  (((Response)[0] & 0x00000003UL) >> 0)

/* Response 2 CSD (card specific data) register writable field masks */
#define SDHC1_R2_FILE_FORMAT_GRP_MASK    0x00000080UL
#define SDHC1_R2_COPY_MASK               0x00000040UL
#define SDHC1_R2_PERM_WRITE_PROTECT_MASK 0x00000020UL
#define SDHC1_R2_TMP_WRITE_PROTECT_MASK  0x00000010UL
#define SDHC1_R2_FILE_FORMAT_MASK        0x0000000CUL
#define SDHC1_R2_ECC_MASK                0x00000003UL

/* Response 2 CID register field access macros */
#define SDHC1_R2_GET_MANUFACTURER_ID(Response)           (((Response)[3] & 0x00FF0000UL) >> 16)
/* Response 2 SD CID register field access macros */
#define SDHC1_R2_SD_GET_OEM_APPLICATION_ID(Response)     (((Response)[3] & 0x0000FFFFUL) >> 0)
#define SDHC1_R2_SD_GET_PRODUCT_NAME(Response)           ((((Response)[2] & 0xFFFFFFFFUL) << 8) | (((Response)[1] & 0xFF000000UL) >> 24))
#define SDHC1_R2_SD_GET_PRODUCT_REVISION(Response)       (((Response)[1] & 0x00FF0000UL) >> 16)
#define SDHC1_R2_SD_GET_PRODUCT_SERIAL_NUMBER(Response)  ((((Response)[1] & 0x0000FFFFUL) << 16) | (((Response)[0] & 0xFFFF0000UL) >> 16))
#define SDHC1_R2_SD_GET_MANUFACTURING_DATE(Response)     (((Response)[0] & 0x00000FFFUL) >> 0)
/* Response 2 MMC CID register field access macros */
#define SDHC1_R2_MMC_GET_CARD_BGA(Response)              (((Response)[3] & 0x00000300UL) >> 8)
#define SDHC1_R2_MMC_GET_OEM_APPLICATION_ID(Response)    (((Response)[3] & 0x000000FFUL) >> 0)
#define SDHC1_R2_MMC_GET_PRODUCT_NAME(Response)          ((((Response)[2] & 0xFFFFFFFFUL) << 16) | (((Response)[1] & 0xFFFF0000UL) >> 16))
#define SDHC1_R2_MMC_GET_PRODUCT_REVISION(Response)      (((Response)[1] & 0x0000FF00UL) >> 8)
#define SDHC1_R2_MMC_GET_PRODUCT_SERIAL_NUMBER(Response) ((((Response)[1] & 0x000000FFUL) << 24) | (((Response)[0] & 0xFFFFFF00UL) >> 8))
#define SDHC1_R2_MMC_GET_MANUFACTURING_DATE(Response)    (((Response)[0] & 0x000000FFUL) >> 0)

/* Response 3 OCR (operation conditions register) access macros */
#define SDHC1_R3_OCR_IS_CARD_POWER_UP(Response)      ((Response)[0] & 0x80000000UL)
#define SDHC1_R3_OCR_IS_CARD_HIGH_CAPACITY(Response) ((Response)[0] & 0x40000000UL)

/* Response 6 field access macros */
#define SDHC1_R6_GET_RCA(Response) ((Response)[0] >> 16)

/* Extended CSD (card specific data) register data block field indices */
#define SDHC1_EXT_CSD_S_CMD_SET_INDEX                   504U
#define SDHC1_EXT_CSD_INI_TIMEOUT_AP_INDEX              241U
#define SDHC1_EXT_CSD_PWR_CL_DDR_52_360_INDEX           239U
#define SDHC1_EXT_CSD_PWR_CL_DDR_52_195_INDEX           238U
#define SDHC1_EXT_CSD_MIN_PERF_DDR_W_8_52_INDEX         235U
#define SDHC1_EXT_CSD_MIN_PERF_DDR_R_8_52_INDEX         234U
#define SDHC1_EXT_CSD_TRIM_MULT_INDEX                   232U
#define SDHC1_EXT_CSD_SEC_FEATURE_SUPPORT_INDEX         231U
#define SDHC1_EXT_CSD_SEC_ERASE_MULT_INDEX              230U
#define SDHC1_EXT_CSD_SEC_TRIM_MULT_INDEX               229U
#define SDHC1_EXT_CSD_BOOT_INFO_INDEX                   228U
#define SDHC1_EXT_CSD_BOOT_SIZE_MULTI_INDEX             226U
#define SDHC1_EXT_CSD_ACC_SIZE_INDEX                    225U
#define SDHC1_EXT_CSD_HC_ERASE_GRP_SIZE_INDEX           224U
#define SDHC1_EXT_CSD_ERASE_TIMEOUT_MULT_INDEX          223U
#define SDHC1_EXT_CSD_REL_WR_SEC_C_INDEX                222U
#define SDHC1_EXT_CSD_HC_WP_GRP_SIZE_INDEX              221U
#define SDHC1_EXT_CSD_S_C_VCC_INDEX                     220U
#define SDHC1_EXT_CSD_S_C_VCCQ_INDEX                    219U
#define SDHC1_EXT_CSD_S_A_TIMEOUT_INDEX                 217U
#define SDHC1_EXT_CSD_SEC_COUNT_INDEX                   212U
#define SDHC1_EXT_CSD_MIN_PERF_W_8_52_INDEX             210U
#define SDHC1_EXT_CSD_MIN_PERF_R_8_52_INDEX             209U
#define SDHC1_EXT_CSD_MIN_PERF_W_8_26_4_52_INDEX        208U
#define SDHC1_EXT_CSD_MIN_PERF_R_8_26_4_52_INDEX        207U
#define SDHC1_EXT_CSD_MIN_PERF_W_4_26_INDEX             206U
#define SDHC1_EXT_CSD_MIN_PERF_R_4_26_INDEX             205U
#define SDHC1_EXT_CSD_PWR_CL_26_360_INDEX               203U
#define SDHC1_EXT_CSD_PWR_CL_52_360_INDEX               202U
#define SDHC1_EXT_CSD_PWR_CL_26_195_INDEX               201U
#define SDHC1_EXT_CSD_PWR_CL_52_195_INDEX               200U
#define SDHC1_EXT_CSD_CARD_TYPE_INDEX                   196U
#define SDHC1_EXT_CSD_CSD_STRUCTURE_INDEX               194U
#define SDHC1_EXT_CSD_EXT_CSD_REV_INDEX                 192U
#define SDHC1_EXT_CSD_CMD_SET_INDEX                     191U
#define SDHC1_EXT_CSD_CMD_SET_REV_INDEX                 189U
#define SDHC1_EXT_CSD_POWER_CLASS_INDEX                 187U
#define SDHC1_EXT_CSD_HS_TIMING_INDEX                   185U
#define SDHC1_EXT_CSD_BUS_WIDTH_INDEX                   183U
#define SDHC1_EXT_CSD_ERASED_MEM_CONT_INDEX             181U
#define SDHC1_EXT_CSD_PARTITION_CONFIG_INDEX            179U
#define SDHC1_EXT_CSD_BOOT_CONFIG_PROT_INDEX            178U
#define SDHC1_EXT_CSD_BOOT_BUS_WIDTH_INDEX              177U
#define SDHC1_EXT_CSD_ERASE_GROUP_DEF_INDEX             175U
#define SDHC1_EXT_CSD_BOOT_WP_INDEX                     173U
#define SDHC1_EXT_CSD_USER_WP_INDEX                     171U
#define SDHC1_EXT_CSD_FW_CONFIG_INDEX                   169U
#define SDHC1_EXT_CSD_RPMB_SIZE_MULT_INDEX              168U
#define SDHC1_EXT_CSD_RST_N_FUNCTION_INDEX              162U
#define SDHC1_EXT_CSD_PARTITIONING_SUPPORT_INDEX        160U
#define SDHC1_EXT_CSD_MAX_ENH_SIZE_MULT_INDEX           157U
#define SDHC1_EXT_CSD_PARTITIONS_ATTRIBUTE_INDEX        156U
#define SDHC1_EXT_CSD_PARTITION_SETTING_COMPLETED_INDEX 155U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_1_0_INDEX            154U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_1_1_INDEX            153U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_1_2_INDEX            152U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_2_0_INDEX            151U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_2_1_INDEX            150U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_2_2_INDEX            149U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_3_0_INDEX            148U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_3_1_INDEX            147U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_3_2_INDEX            146U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_4_0_INDEX            145U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_4_1_INDEX            144U
#define SDHC1_EXT_CSD_GP_SIZE_MULT_4_2_INDEX            143U
#define SDHC1_EXT_CSD_ENH_SIZE_MULT_INDEX               140U
#define SDHC1_EXT_CSD_ENH_START_ADDR_INDEX              136U
#define SDHC1_EXT_CSD_SEC_BAD_BLK_MGMNT_INDEX           134U

/* SCR (SD card configuration register) data block field access macros */
#define SDHC1_SCR_GET_SCR_STRUCTURE(Response)         ((((uint8_t*)(Response))[0] & 0xF0U) >> 4)
#define SDHC1_SCR_GET_SD_SPEC(Response)               ((((uint8_t*)(Response))[0] & 0x0FU) >> 0)
  #define SDHC1_SCR_SD_SPEC_VERS_1_0X 0U
  #define SDHC1_SCR_SD_SPEC_VERS_1_10 1U
  #define SDHC1_SCR_SD_SPEC_VERS_2_00 2U
#define SDHC1_SCR_GET_DATA_STAT_AFTER_ERASE(Response) ((((uint8_t*)(Response))[1] & 0x80U) >> 7)
#define SDHC1_SCR_GET_SD_SECURITY(Response)           ((((uint8_t*)(Response))[1] & 0x70U) >> 4)
#define SDHC1_SCR_GET_SD_BUS_WIDTHS(Response)         ((((uint8_t*)(Response))[1] & 0x0FU) >> 0)
  #define SDHC1_SCR_SD_BUS_WIDTH_1_BIT_MASK 0x01U
  #define SDHC1_SCR_SD_BUS_WIDTH_4_BIT_MASK 0x04U

/* Switch function status block position in the component's card data structure info block */
#define SDHC1_SFS_BLOCK_START 8U
/* Switch function status block field access macros */
#define SDHC1_SFS_IS_FUNC_SUPPORTED(Response, Group, Index) ((SDHC1_BE_TO_NE16(((uint16_t*)(Response))[6U - ((Group) - 1U)]) >> (Index)) & 1U)
  #define SDHC1_SFS_HIGH_SPEED_FUNC_GROUP 1U
  #define SDHC1_SFS_HIGH_SPEED_FUNC_INDEX 1U

/* Voltage validation substates */
#define SDHC1_VV_START      0U
#define SDHC1_VV_SDHC_CHECK 1U
#define SDHC1_VV_SD_CHECK   2U
#define SDHC1_VV_MMC_CHECK  3U
#define SDHC1_VV_FINISH     4U

/* Card registration substates */
#define SDHC1_CR_START   0U
#define SDHC1_CR_GET_CID 1U
#define SDHC1_CR_GET_RCA 2U
#define SDHC1_CR_FINISH  3U

/* Card info retrieval substates */
#define SDHC1_CIR_START                0U
#define SDHC1_CIR_STAND_BY_STATE       1U
#define SDHC1_CIR_GET_CSD              2U
#define SDHC1_CIR_TRANSFER_STATE       3U
#define SDHC1_CIR_GET_EXT_CSD          4U
#define SDHC1_CIR_BUS_TEST_4_BIT_WRITE 5U
#define SDHC1_CIR_BUS_TEST_4_BIT_READ  6U
#define SDHC1_CIR_BUS_TEST_8_BIT_WRITE 7U
#define SDHC1_CIR_BUS_TEST_8_BIT_READ  8U
#define SDHC1_CIR_GET_SCR              9U
#define SDHC1_CIR_GET_FUNC_STATUS      10U
#define SDHC1_CIR_FINISH               11U

/* Blocks erasion substates */
#define SDHC1_E_SET_START 0U
#define SDHC1_E_SET_END   1U
#define SDHC1_E_EXECUTE   2U
#define SDHC1_E_FINISH    3U

/* Data width selection substates */
#define SDHC1_DWS_START  0U
#define SDHC1_DWS_BUSY   1U
#define SDHC1_DWS_FINISH 2U

/* Command states */
#define SDHC1_CMD_DATA_LEN 0U
#define SDHC1_CMD_START    1U
#define SDHC1_CMD_ACMD     2U
#define SDHC1_CMD_FINISH   3U
#define SDHC1_CMD_DATA     4U
#define SDHC1_CMD_ERROR    5U

typedef enum {
  SDHC1_IDLE = 0,
  SDHC1_READY = 1,
  SDHC1_IDENT = 2,
  SDHC1_STAND_BY = 3,
  SDHC1_TRANSFER = 4,
  SDHC1_SENDING = 5,
  SDHC1_RECEIVE = 6,
  SDHC1_PROGRAMMING = 7,
  SDHC1_DISCONNECT = 8,
  SDHC1_BUS_TEST = 9,
  SDHC1_SLEEP = 10
} SDHC1_TCardState;

typedef struct {
  bool               Initialized;      /* Indicates if the structure contains valid card data */
  LDD_SDHC_TCardType Type;             /* Card type (see SDHC1_TCardType) */
  uint32_t           CID[4];           /* Card ID (from the card) */
  uint16_t           RCA;              /* Relative card address */
  uint32_t           CSD[4];           /* The CSD (card specific data) register value retrieved from the card */
  uint8_t            Block[512];       /* The extended CSD (card specific data) or SCR (SD card configuration register) value retrieved from the card */
  uint8_t            DataWidths;       /* Data widths succeeded in bus test */
  bool               HighCapacity;     /* Indicates block addressing requirement */
} SDHC1_TCardInfo;

/* ADMA2 transfer buffer descriptor attribute constants */
#define SDHC1_ADMA2_VALID         0x0001U /* Descriptor line is valid */
#define SDHC1_ADMA2_END           0x0002U /* Descriptor line is ending */
#define SDHC1_ADMA2_INT           0x0004U /* Generate interrupt when the descriptor is done*/
#define SDHC1_ADMA2_ATTR_ACT_NOP  0x0000U /* No operation */
#define SDHC1_ADMA2_ATTR_ACT_RSV  0x0010U /* Reserved (no operation) */
#define SDHC1_ADMA2_ATTR_ACT_TRAN 0x0020U /* Transfer data with address and length set in this descriptor line */
#define SDHC1_ADMA2_ATTR_ACT_LINK 0x0030U /* Link to another descriptor */
#define SDHC1_SINGLE_BLOCK_TRANS_ATTRS (SDHC1_ADMA2_VALID | SDHC1_ADMA2_END | SDHC1_ADMA2_ATTR_ACT_TRAN)

typedef struct {
  uint16_t Attributes;                 /* Transfer buffer attributes */
  uint16_t Length;                     /* Transfer buffer data length */
  uint32_t Address;                    /* Transfer buffer data address */
} SDHC1_TTransferBufferDesc;

#define SDHC1_TRANSFER_TABLE_ALIGN  4U /* Transfer table memory alignment */
#define SDHC1_TRANSFER_BUFFER_ALIGN 4U /* Transfer buffer memory alignment */

/* Pins port register bit indices where to configure pulls */
#define SDHC1_PIN_CMD_PORT_INDEX  3U
#define SDHC1_PIN_DAT0_PORT_INDEX 1U

typedef struct {
  bool               Enabled;          /* Indicates whether the device is enabled */
  LDD_TUserData      *UserDataPtr;     /* User data structure pointer */
  LDD_TEventMask     EventMask;        /* Event mask used for run-time enabling and disabling of events */
  LDD_SDHC_TStatus   State;            /* Main state of the component */
  uint8_t            Substate;         /* Substate of main state */
  uint8_t            CmdState;         /* Card command state */
  uint8_t            CardId;           /* Card ID of the selected card */
  uint8_t            NewCardId;        /* Card ID actually registered during card registration */
  LDD_SDHC_TCardType CardType;         /* Card type actually identified during voltage validation or the type of the selected card */
  bool               HighCapacity;     /* High capacity card indication. Needed for special initialization of SDHC cards. */
  SDHC1_TCardState   CardState;        /* State of the selected card */
  bool               HighVoltage;      /* Indicates whether high bus voltage is currently set */
  uint32_t           CardsVoltages;    /* Mask of voltages supported by all cards */
  uint16_t           RetryCounter;     /* Counter for command timeout until give up */
  SDHC1_TCardInfo    Cards[SDHC1_MAX_CARD_NUMBER]; /* Card data structures list */
  LDD_SDHC_TError    LastError;        /* The last error that has occurred during a card operation */
  uint32_t           LastErrorAddress; /* Card memory address of the last correctly accessed location before an error has occurred */
  uint8_t            TransferTableMem[(SDHC1_BUFFER_TABLE_SIZE * sizeof(SDHC1_TTransferBufferDesc)) + SDHC1_TRANSFER_TABLE_ALIGN]; /* Memory for the transfer buffer descriptors table */
  SDHC1_TTransferBufferDesc *TransferTable; /* Pointer to the transfer buffer descriptors table */
  uint32_t           TransferBlockSize; /* Size of buffers to transfer */
  uint32_t           TransferBlockCount; /* Number of buffers to transfer */
  LDD_SDHC_TCardInfo *CardInfoPtr;     /* Card info structure pointer where to store the result of the GetCardInfo method call */
  LDD_SDHC_TTransferOperation TransferOperation; /* Ongoing transfer operation */
  uint32_t           Address;          /* Card memory address used in an ongoing operation */
  uint8_t            DataWidth;        /* Communication data width currently set */
  SDHC1_TBusClock    Frequency;        /* Bus clock frequency currently set */
  LDD_TClockConfiguration SpeedMode;   /* Clock configuration currently set */
  bool               EnabledMode;      /* Indicates whether the device is enabled in the current clock configuration */
} SDHC1_TDeviceData;

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static SDHC1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static SDHC1_TDeviceData* INT_SDHC__DEFAULT_RTOS_ISRPARAM;

/* Internal method prototypes */
static void VoltageValidation(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static void CardRegistration(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static void CardInfoRetrieval(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool CardSelection(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool Transfer(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static LDD_SDHC_TError GetCommandError(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static void SendCardStatusRequest(LDD_TDeviceData *DeviceDataPtr);
static void EventHandler(LDD_TDeviceData *DeviceDataPtr);

/*
** ===================================================================
**     Method      :  SDHC1_Init (component SDHC_LDD)
*/
/*!
**     @brief
**         Initializes the device. Allocates memory for the device data
**         structure, allocates interrupt vectors and sets interrupt
**         priority, sets pin routing, sets timing, etc. If the
**         property <"Enable device"> is set to "yes" then the device
**         is also enabled (see the description of the <Enable> method).
**         In this case the <Enable> method is not necessary and need
**         not to be generated. This method can be called only once.
**         Before the second call of Init the <Deinit> method must be
**         called first.
**     @param
**         UserDataPtr     - Pointer to user data
**                           structure pointer.
**     @return
**                         - Pointer to the device data structure. 
*/
/* ===================================================================*/
LDD_TDeviceData* SDHC1_Init(LDD_TUserData *UserDataPtr)
{
  SDHC1_TDeviceData *DeviceDataPrv;
  uint8_t Id;
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;

  /* Initialize the device data */
  DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the user data pointer */
  DeviceDataPrv->CardId = SDHC1_NO_CARD; /* No card will be selected */
  DeviceDataPrv->State = LDD_SDHC_RESET; /* Cards will be reseted after host initialization */
  DeviceDataPrv->HighVoltage = TRUE;   /* Initially set bus voltage to high */
  DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
  for (Id = 0; Id < SDHC1_MAX_CARD_NUMBER; Id++) {
    DeviceDataPrv->Cards[Id].Initialized = FALSE;
  }
  DeviceDataPrv->TransferTable = (SDHC1_TTransferBufferDesc*) /* Align transfer buffer table memory according to hardware requirements */
    (((uint32_t)DeviceDataPrv->TransferTableMem + SDHC1_TRANSFER_TABLE_ALIGN) & (uint32_t)(~(uint32_t)(SDHC1_TRANSFER_TABLE_ALIGN - 1U)));
  DeviceDataPrv->DataWidth = LDD_SDHC_CARD_DATA_WIDTH_1_BIT; /* Set default data width */
  DeviceDataPrv->SpeedMode = CPU_CLOCK_CONFIG_0; /* Set initial clock configuration */
  DeviceDataPrv->EventMask =           /* Initialize the event mask */
    LDD_SDHC_ON_CARD_INSERTED |
    LDD_SDHC_ON_CARD_REMOVED |
    LDD_SDHC_ON_FINISHED | 0U;
  DeviceDataPrv->EnabledMode = TRUE;   /* Enable the device clock configuration */
  /* SIM_SCGC3: SDHC=1 */
  SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
  /* Set pin assignments */
  /* PORTE_PCR2: ISF=0,MUX=4 */
  PORTE_PCR2 = (uint32_t)((PORTE_PCR2 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* PORTE_PCR3: ISF=0,MUX=4 */
  PORTE_PCR3 = (uint32_t)((PORTE_PCR3 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* Enable and set pull-up on command pin */
  PORT_PDD_SetPinPullSelect(PORTE_BASE_PTR, SDHC1_PIN_CMD_PORT_INDEX, PORT_PDD_PULL_UP);
  PORT_PDD_SetPinPullEnable(PORTE_BASE_PTR, SDHC1_PIN_CMD_PORT_INDEX, PORT_PDD_PULL_ENABLE);
  PORT_PDD_SetPinDriveStrength(PORTE_BASE_PTR, SDHC1_PIN_CMD_PORT_INDEX, PORT_PDD_DRIVE_STRENGTH_HIGH);
  /* PORTE_PCR1: ISF=0,MUX=4 */
  PORTE_PCR1 = (uint32_t)((PORTE_PCR1 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* Enable and set pull-up on data pins */
  PORT_PDD_SetPinPullSelect(PORTE_BASE_PTR, SDHC1_PIN_DAT0_PORT_INDEX, PORT_PDD_PULL_UP);
  PORT_PDD_SetPinPullEnable(PORTE_BASE_PTR, SDHC1_PIN_DAT0_PORT_INDEX, PORT_PDD_PULL_ENABLE);
  PORT_PDD_SetPinDriveStrength(PORTE_BASE_PTR, SDHC1_PIN_DAT0_PORT_INDEX, PORT_PDD_DRIVE_STRENGTH_HIGH);
  /* Configure card detection and DMA mode */
  /* SDHC_PROCTL: ??=0,??=0,??=0,??=0,??=0,WECRM=0,WECINS=0,WECINT=0,??=0,??=0,??=0,??=0,IABG=0,RWCTL=0,CREQ=0,SABGREQ=0,??=0,??=0,??=0,??=0,??=0,??=0,DMAS=2,CDSS=0,CDTL=0,EMODE=2,D3CD=0,DTW=0,LCTL=0 */
  SDHC_PROCTL = SDHC_PROCTL_DMAS(0x02) |
                SDHC_PROCTL_EMODE(0x02) |
                SDHC_PROCTL_DTW(0x00);
  /* Set DMA watermark levels */
  /* SDHC_WML: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,WRWML=0x10,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RDWML=0x10 */
  SDHC_WML = (SDHC_WML_WRWML(0x10) | SDHC_WML_RDWML(0x10));
  /* SDHC_VENDOR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,INTSTVAL=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,EXBLKNU=0,EXTDMAEN=0 */
  SDHC_VENDOR = SDHC_VENDOR_INTSTVAL(0x00);
  /* SIM_SOPT2: SDHCSRC=2 */
  SIM_SOPT2 = (uint32_t)((SIM_SOPT2 & (uint32_t)~(uint32_t)(
               SIM_SOPT2_SDHCSRC(0x01)
              )) | (uint32_t)(
               SIM_SOPT2_SDHCSRC(0x02)
              ));
  /* Set bus clock frequency and data timeout */
  /* SDHC_SYSCTL: ??=0,??=0,??=0,??=0,INITA=0,RSTD=0,RSTC=0,RSTA=0,??=0,??=0,??=0,??=0,DTOCV=7,SDCLKFS=4,DVS=4,SDCLKEN=0,PEREN=0,HCKEN=0,IPGEN=0 */
  SDHC_SYSCTL = SDHC_SYSCTL_DTOCV(0x07) |
                SDHC_SYSCTL_SDCLKFS(0x04) |
                SDHC_SYSCTL_DVS(0x04);
  while (!SDHC_PDD_IsSDClockStable(SDHC_BASE_PTR)) {} /* Wait for clock to stabilize */
  /* SDHC_SYSCTL: ??=0,??=0,??=0,??=0,INITA=0,RSTD=0,RSTC=0,RSTA=0,??=0,??=0,??=0,??=0,DTOCV=7,SDCLKFS=4,DVS=4,SDCLKEN=1,PEREN=1,HCKEN=1,IPGEN=1 */
  SDHC_SYSCTL = SDHC_SYSCTL_DTOCV(0x07) |
                SDHC_SYSCTL_SDCLKFS(0x04) |
                SDHC_SYSCTL_DVS(0x04) |
                SDHC_SYSCTL_SDCLKEN_MASK |
                SDHC_SYSCTL_PEREN_MASK |
                SDHC_SYSCTL_HCKEN_MASK |
                SDHC_SYSCTL_IPGEN_MASK;
  /* Set interrupt priorities */
  /* NVICIP81: PRI81=0x70 */
  NVICIP81 = NVIC_IP_PRI81(0x70);
  /* NVICISER2: SETENA|=0x00020000 */
  NVICISER2 |= NVIC_ISER_SETENA(0x00020000);
  /* Allocate the interrupt vector */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_SDHC__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  /* Enable and clear status flags */
  /* SDHC_IRQSTAT: ??=1,??=1,??=1,DMAE=1,??=1,??=1,??=1,AC12E=1,??=1,DEBE=1,DCE=1,DTOE=1,CIE=1,CEBE=1,CCE=1,CTOE=1,??=1,??=1,??=1,??=1,??=1,??=1,??=1,CINT=1,CRM=1,CINS=1,BRR=1,BWR=1,DINT=1,BGE=1,TC=1,CC=1 */
  SDHC_IRQSTAT = SDHC_IRQSTAT_DMAE_MASK |
                 SDHC_IRQSTAT_AC12E_MASK |
                 SDHC_IRQSTAT_DEBE_MASK |
                 SDHC_IRQSTAT_DCE_MASK |
                 SDHC_IRQSTAT_DTOE_MASK |
                 SDHC_IRQSTAT_CIE_MASK |
                 SDHC_IRQSTAT_CEBE_MASK |
                 SDHC_IRQSTAT_CCE_MASK |
                 SDHC_IRQSTAT_CTOE_MASK |
                 SDHC_IRQSTAT_CINT_MASK |
                 SDHC_IRQSTAT_CRM_MASK |
                 SDHC_IRQSTAT_CINS_MASK |
                 SDHC_IRQSTAT_BRR_MASK |
                 SDHC_IRQSTAT_BWR_MASK |
                 SDHC_IRQSTAT_DINT_MASK |
                 SDHC_IRQSTAT_BGE_MASK |
                 SDHC_IRQSTAT_TC_MASK |
                 SDHC_IRQSTAT_CC_MASK |
                 0xEE80FE00U;
  /* SDHC_IRQSIGEN: ??=0,??=0,??=0,DMAEIEN=0,??=0,??=0,??=0,AC12EIEN=0,??=0,DEBEIEN=0,DCEIEN=0,DTOEIEN=0,CIEIEN=0,CEBEIEN=0,CCEIEN=0,CTOEIEN=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,CINTIEN=0,CRMIEN=0,CINSIEN=0,BRRIEN=0,BWRIEN=0,DINTIEN=0,BGEIEN=0,TCIEN=1,CCIEN=1 */
  SDHC_IRQSIGEN = (SDHC_IRQSIGEN_TCIEN_MASK | SDHC_IRQSIGEN_CCIEN_MASK);
  /* SDHC_IRQSTATEN: ??=1,??=1,??=1,DMAESEN=1,??=1,??=1,??=1,AC12ESEN=1,??=1,DEBESEN=1,DCESEN=1,DTOESEN=1,CIESEN=1,CEBESEN=1,CCESEN=1,CTOESEN=1,??=1,??=1,??=1,??=1,??=1,??=1,??=1,CINTSEN=1,CRMSEN=0,CINSEN=0,BRRSEN=0,BWRSEN=0,DINTSEN=1,BGESEN=1,TCSEN=1,CCSEN=1 */
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_DMAESEN_MASK |
                   SDHC_IRQSTATEN_AC12ESEN_MASK |
                   SDHC_IRQSTATEN_DEBESEN_MASK |
                   SDHC_IRQSTATEN_DCESEN_MASK |
                   SDHC_IRQSTATEN_DTOESEN_MASK |
                   SDHC_IRQSTATEN_CIESEN_MASK |
                   SDHC_IRQSTATEN_CEBESEN_MASK |
                   SDHC_IRQSTATEN_CCESEN_MASK |
                   SDHC_IRQSTATEN_CTOESEN_MASK |
                   SDHC_IRQSTATEN_CINTSEN_MASK |
                   SDHC_IRQSTATEN_DINTSEN_MASK |
                   SDHC_IRQSTATEN_BGESEN_MASK |
                   SDHC_IRQSTATEN_TCSEN_MASK |
                   SDHC_IRQSTATEN_CCSEN_MASK |
                   0xEE80FE00U;
  /* Power up cards */
  SDHC_PDD_InitCard(SDHC_BASE_PTR);
  while (!SDHC_PDD_IsCardInitComplete(SDHC_BASE_PTR)) {}
  /* Reset cards */
  SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
  SDHC_PDD_SendCommand(SDHC_BASE_PTR,
    SDHC_PDD_CMD0_GO_IDLE_STATE, SDHC_PDD_NO_RESPONSE);
  DeviceDataPrv->Enabled = TRUE;       /* Enable the component */
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_SDHC1_ID,DeviceDataPrv);
  return DeviceDataPrv;
}

/*
** ===================================================================
**     Method      :  SDHC1_DetectCards (component SDHC_LDD)
*/
/*!
**     @brief
**         Detects newly inserted and removed cards. The OnCardInserted
**         event will be called for every new card and the
**         OnCardRemoved event will be called for every removed card.
**         This method should be used when card detection pin is not
**         available.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Card detection started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC1_DetectCards(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */

  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->State = LDD_SDHC_VOLTAGE_VALIDATION;
    DeviceDataPrv->Substate = SDHC1_VV_START;
    VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC1_SelectCard (component SDHC_LDD)
*/
/*!
**     @brief
**         Selects a card by its identification number. All further
**         operations will apply to this card. Special card
**         identification number <compId>_NO_CARD will deselect the
**         active card.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Id              - Card identification number passed by the
**                           OnCardInserted event parameter.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Card selection started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
**                           ERR_PARAM_ID - Invalid card ID
*/
/* ===================================================================*/
LDD_TError SDHC1_SelectCard(LDD_TDeviceData *DeviceDataPtr, uint8_t Id)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  uint32_t Argument;                   /* Card command argument */

  if (Id != SDHC1_NO_CARD) {
    if (!DeviceDataPrv->Cards[Id].Initialized) {
      return ERR_PARAM_ID;
    }
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    if (Id != DeviceDataPrv->CardId) {
      /* Change card selection */
      DeviceDataPrv->CardId = Id;
      if (Id != SDHC1_NO_CARD) {       /* Select card */
        DeviceDataPrv->CardType = DeviceDataPrv->Cards[Id].Type; /* Store currently selected card's type */
        Argument = SDHC1_CMD_ARG_RCA((uint32_t)DeviceDataPrv->Cards[Id].RCA); /* Select card by its RCA */
      } else {                         /* Unselect card */
        Argument = 0U;                 /* Zero is a special RCA (relative card address) for deselecting all cards */
      }
      DeviceDataPrv->State = LDD_SDHC_CARD_SELECTION;
      /* Send card selection command */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, Argument);
      SDHC_PDD_SendCommand(SDHC_BASE_PTR,
        SDHC_PDD_CMD7_SELECT_CARD, SDHC_PDD_RESPONSE_LENGTH_48_BUSY_CHECK);
    } else {
      Result = ERR_PARAM_ID;           /* Reselecting an already selected card is an illegal card operation */
    }
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC1_GetCardInfo (component SDHC_LDD)
*/
/*!
**     @brief
**         Returns card information about the selected card. Method
**         call starts the card information retrieval process. After
**         the card information has been received, the OnFinished event
**         is called (the component state changes to idle) and the
**         information is stored in the specified variable.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         InfoPtr         - Pointer to a variable, where card
**                           information will be stored.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Card information retrieval started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC1_GetCardInfo(LDD_TDeviceData *DeviceDataPtr, LDD_SDHC_TCardInfo *InfoPtr)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */

  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->CardInfoPtr = InfoPtr; /* Store a pointer to the card info variable for later card info update */
    /* Start card information retrieval */
    DeviceDataPrv->State = LDD_SDHC_CARD_INFO_RETRIEVAL;
    DeviceDataPrv->Substate = SDHC1_CIR_START;
    CardInfoRetrieval(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card info retrieval state */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC1_TransferBlocks (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a data block transfer on the selected card.
**         Transfer can be a read or write operation depending on the
**         transfer operation parameter. Read operation reads data
**         blocks from the specified address on a memory card and
**         stores their content into buffers specified by the buffer
**         descriptor list. Write operation writes data blocks
**         specified by the buffer descriptor list to a card memory on
**         the specified address. Data blocks should be the same size
**         and the block size should be supported by the memory card.
**         Buffer addresses should be aligned to a hardware specific
**         address boundary.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Operation       - Transfer operation
**     @param
**         Address         - Card memory address. Byte address
**                           in case of standard capacity memory cards,
**                           512 byte block number in case of high
**                           capacity memory cards.
**     @param
**         BufferDescListPtr - Pointer to
**                           data block buffer descriptor list.
**     @param
**         BufferDescCount - Data block buffer
**                           descriptor list item count
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Transfer started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
**                           ERR_PARAM_ADDRESS - Invalid buffer address
**                           (one or more buffer address from the list
**                           of buffer descriptors is misaligned)
**                           ERR_PARAM_BUFFER_COUNT - Buffer count
**                           exceeds the internal buffer table size
*/
/* ===================================================================*/
LDD_TError SDHC1_TransferBlocks(LDD_TDeviceData *DeviceDataPtr, LDD_SDHC_TTransferOperation Operation, uint32_t Address, LDD_SDHC_TBufferDesc *BufferDescListPtr, uint16_t BufferDescCount)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  uint32_t Index;                      /* Transfer table index */
  bool Finished;                       /* Indicates whether transfer has finished */

  if ((BufferDescCount == 0U) || (BufferDescCount > SDHC1_BUFFER_TABLE_SIZE)) {
    return ERR_PARAM_BUFFER_COUNT;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->TransferBlockSize = BufferDescListPtr[0].Size; /* Determine block size from first buffer size */
    DeviceDataPrv->TransferBlockCount = BufferDescCount; /* Determine block count from buffer count */
    /* Fill in the transfer descriptors table */
    for (Index = 0U; Index < BufferDescCount; Index++) {
      DeviceDataPrv->TransferTable[Index].Attributes = /* Mark each transfer buffer descriptor as ready for transfer */
        SDHC1_ADMA2_VALID | SDHC1_ADMA2_ATTR_ACT_TRAN;
      DeviceDataPrv->TransferTable[Index].Length = BufferDescListPtr[Index].Size; /* Copy transfer buffer size */
      DeviceDataPrv->TransferTable[Index].Address = (uint32_t)BufferDescListPtr[Index].DataPtr; /* Copy transfer buffer address */
    }
    DeviceDataPrv->TransferTable[BufferDescCount - 1U].Attributes |= SDHC1_ADMA2_END; /* Mark the last descriptor as last */
    DeviceDataPrv->TransferOperation = Operation; /* Store the transfer operation type */
    DeviceDataPrv->Address = Address;  /* Store the source/destination address for the read/write operation */
    /* Start data transfer */
    DeviceDataPrv->State = LDD_SDHC_TRANSFER;
    DeviceDataPrv->CmdState = SDHC1_CMD_DATA_LEN;
    Finished = Transfer(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the transfer state */
    (void)Finished;                    /* The return value is not used */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC1_GetStatus (component SDHC_LDD)
*/
/*!
**     @brief
**         Returns the current component status, specifying the ongoing
**         operation.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @return
**                         -  Component status.
*/
/* ===================================================================*/
LDD_SDHC_TStatus SDHC1_GetStatus(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;

  return DeviceDataPrv->State;
}

/*
** ===================================================================
**     Method      :  SDHC1_GetError (component SDHC_LDD)
*/
/*!
**     @brief
**         Returns the last error code and the memory address where the
**         error occurred (if applicable).
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         AddressPtr      - Pointer to a variable, where
**                           the error address will be stored.
**     @return
**                         -  The last error code.
*/
/* ===================================================================*/
LDD_SDHC_TError SDHC1_GetError(LDD_TDeviceData *DeviceDataPtr, uint32_t *AddressPtr)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  LDD_SDHC_TError Error;               /* Error code storage */

  Error = DeviceDataPrv->LastError;
  if (AddressPtr) {
    *AddressPtr = DeviceDataPrv->LastErrorAddress;
  }
  return Error;
}

/*
** ===================================================================
**     Method      :  SDHC1_VoltageValidation (component SDHC_LDD)
**
**     Description :
**         Voltage validation state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void VoltageValidation(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */

  switch (DeviceDataPrv->Substate) {
    case SDHC1_VV_START:
      DeviceDataPrv->CardsVoltages = 0;
      /* Start with SD card version 2.0 or later interface conditions check */
      DeviceDataPrv->Substate = SDHC1_VV_SDHC_CHECK;
      DeviceDataPrv->CmdState = SDHC1_CMD_START;
      VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
      break;
    case SDHC1_VV_SDHC_CHECK:
      switch (DeviceDataPrv->CmdState) {
        case SDHC1_CMD_START:
          DeviceDataPrv->CmdState = SDHC1_CMD_FINISH;
          /* Send interface conditions request command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
            ((DeviceDataPrv->HighVoltage == TRUE) ? /* Propose bus voltage configuration */
              SDHC1_IF_COND_HIGH_VOLTAGE_MASK :
              SDHC1_IF_COND_LOW_VOLTAGE_MASK) |
            SDHC1_IF_COND_CHECK_PATTERN);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD8_SEND_EXT_CSD, SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC1_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->HighCapacity = TRUE; /* Card is an SD card version 2.0 or later (possibly high capacity) */
          } else if (Error == LDD_SDHC_ERR_TIMEOUT) {
            DeviceDataPrv->HighCapacity = FALSE; /* Card is a normal SD or other type of card */
          } else {
            DeviceDataPrv->LastError = Error;
          }
          /* Continue with SD card interface conditions check */
          DeviceDataPrv->Substate = SDHC1_VV_SD_CHECK;
          DeviceDataPrv->CmdState = SDHC1_CMD_START;
          DeviceDataPrv->RetryCounter = SDHC1_VOLT_VALID_RETRY_COUNT; /* Limit the interface conditions request number */
          VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
          break;
        default:
          break;
      }
      break;
    case SDHC1_VV_SD_CHECK:
      switch (DeviceDataPrv->CmdState) {
        case SDHC1_CMD_START:
          DeviceDataPrv->CmdState = SDHC1_CMD_ACMD;
          /* Start application specific command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD55_APP_CMD, SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC1_CMD_ACMD:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if ((Error == LDD_SDHC_ERR_OK) || (Error == LDD_SDHC_ERR_INTERNAL_FAILURE)) {
            DeviceDataPrv->CmdState = SDHC1_CMD_FINISH;
            /* Send OCR (operation conditions register) request */
            SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
              ((DeviceDataPrv->HighCapacity == TRUE) ? SDHC1_OCR_HIGH_CAPACITY_MASK : 0U) |
              ((DeviceDataPrv->HighVoltage == TRUE) ? /* Propose bus voltage configuration */
                SDHC1_OCR_HIGH_VOLTAGE_MASK :
                SDHC1_OCR_LOW_VOLTAGE_MASK));
            SDHC_PDD_SendCommand(SDHC_BASE_PTR,
              SDHC_PDD_ACMD41_SD_APP_OP_COND, SDHC_PDD_RESPONSE_LENGTH_48);
          } else {
            if (Error == LDD_SDHC_ERR_COMMAND_CRC) {
              DeviceDataPrv->LastError = Error;
            }
            /* No more SD card, check MMC cards */
            DeviceDataPrv->Substate = SDHC1_VV_MMC_CHECK;
            DeviceDataPrv->CmdState = SDHC1_CMD_START;
            DeviceDataPrv->RetryCounter = SDHC1_VOLT_VALID_RETRY_COUNT; /* Limit the interface conditions request number */
            VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
          }
          break;
        case SDHC1_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) && Response) {
            if (SDHC1_R3_OCR_IS_CARD_POWER_UP(Response)) {
              /* Card is powered up, start the registration */
              DeviceDataPrv->CardType = LDD_SDHC_SD;
              DeviceDataPrv->CardsVoltages |= *Response & /* Save card voltage capabilities */
                (SDHC1_OCR_HIGH_VOLTAGE_MASK | SDHC1_OCR_LOW_VOLTAGE_MASK);
              DeviceDataPrv->HighCapacity = (SDHC1_R3_OCR_IS_CARD_HIGH_CAPACITY(Response)) ? TRUE : FALSE;
              DeviceDataPrv->State = LDD_SDHC_CARD_REGISTRATION;
              DeviceDataPrv->Substate = SDHC1_CR_START;
              CardRegistration(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card registration state */
            } else if (DeviceDataPrv->RetryCounter--) {
              /* Card is not powered up yet, resend request */
              DeviceDataPrv->CmdState = SDHC1_CMD_START;
              VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
            } else {
              /* Power up reached timeout, check MMC cards */
              DeviceDataPrv->LastError = LDD_SDHC_ERR_TIMEOUT;
              DeviceDataPrv->Substate = SDHC1_VV_MMC_CHECK;
              DeviceDataPrv->CmdState = SDHC1_CMD_START;
            }
          } else {
            if (Error == LDD_SDHC_ERR_COMMAND_CRC) {
              DeviceDataPrv->LastError = Error;
            }
            /* No response for ACMD41, check MMC cards */
            DeviceDataPrv->Substate = SDHC1_VV_MMC_CHECK;
            DeviceDataPrv->CmdState = SDHC1_CMD_START;
          }
          if (DeviceDataPrv->Substate == SDHC1_VV_MMC_CHECK) {
            DeviceDataPrv->RetryCounter = SDHC1_VOLT_VALID_RETRY_COUNT; /* Limit the interface conditions request number */
            /* Send reset command */
            SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
            SDHC_PDD_SendCommand(SDHC_BASE_PTR,
              SDHC_PDD_CMD0_GO_IDLE_STATE, SDHC_PDD_NO_RESPONSE);
          }
          break;
        default:
          break;
      }
      break;
    case SDHC1_VV_MMC_CHECK:
      switch (DeviceDataPrv->CmdState) {
        case SDHC1_CMD_START:
          DeviceDataPrv->CmdState = SDHC1_CMD_FINISH;
          /* Send OCR (operation conditions register) request */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
            ((DeviceDataPrv->HighVoltage == TRUE) ? /* Propose bus voltage configuration */
              SDHC1_OCR_HIGH_VOLTAGE_MASK :
              SDHC1_OCR_LOW_VOLTAGE_MASK) |
            SDHC1_OCR_HIGH_CAPACITY_MASK); /* Indicate high capacity card support by the host */
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD1_SEND_OP_COND, SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC1_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) && Response) {
            if (SDHC1_R3_OCR_IS_CARD_POWER_UP(Response)) {
              /* Card is powered up, start the registration */
              DeviceDataPrv->CardType = LDD_SDHC_MMC;
              DeviceDataPrv->CardsVoltages |= *Response & /* Save card voltage capabilities */
                (SDHC1_OCR_HIGH_VOLTAGE_MASK | SDHC1_OCR_LOW_VOLTAGE_MASK);
              DeviceDataPrv->HighCapacity = (SDHC1_R3_OCR_IS_CARD_HIGH_CAPACITY(Response)) ? TRUE : FALSE;
              DeviceDataPrv->State = LDD_SDHC_CARD_REGISTRATION;
              DeviceDataPrv->Substate = SDHC1_CR_START;
              CardRegistration(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card registration state */
            } else if (DeviceDataPrv->RetryCounter--) {
              /* Card is not powered up yet, resend request */
              DeviceDataPrv->CmdState = SDHC1_CMD_START;
              VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
            } else {
              /* Power up reached timeout, finish */
              DeviceDataPrv->LastError = LDD_SDHC_ERR_TIMEOUT;
              DeviceDataPrv->Substate = SDHC1_VV_FINISH;
              VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
            }
          } else {
            if (Error == LDD_SDHC_ERR_COMMAND_CRC) {
              DeviceDataPrv->LastError = Error;
            }
            /* No more MMC card, finish */
            DeviceDataPrv->Substate = SDHC1_VV_FINISH;
            VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
          }
          break;
        default:
          break;
      }
      break;
    case SDHC1_VV_FINISH:
      DeviceDataPrv->State = LDD_SDHC_IDLE;
      SDHC1_OnFinished(DeviceDataPrv->UserDataPtr); /* Call the user event */
      break;
    default:
      break;
  }
}

/*
** ===================================================================
**     Method      :  CardRegistration (component SDHC_LDD)
**
**     Description :
**         Card registration state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void CardRegistration(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint8_t Id;                          /* Card ID storage */
  uint32_t Index;                      /* Array index */

  switch (DeviceDataPrv->Substate) {
    case SDHC1_CR_START:
      switch (DeviceDataPrv->CardType) {
        case LDD_SDHC_SD:
        case LDD_SDHC_MMC:
          /* Send CID register request */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD2_ALL_SEND_CID, SDHC_PDD_RESPONSE_LENGTH_136);
          DeviceDataPrv->Substate = SDHC1_CR_GET_CID;
          break;
        default:
          break;
      }
      break;
    case SDHC1_CR_GET_CID:
      switch (DeviceDataPrv->CardType) {
        case LDD_SDHC_SD:
        case LDD_SDHC_MMC:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) && Response) {
            /* Assign a free data structure to the card */
            for (Id = 0U; Id < SDHC1_MAX_CARD_NUMBER; Id++) {
              if (!DeviceDataPrv->Cards[Id].Initialized) {
                /* Initialize the data structure */
                DeviceDataPrv->NewCardId = Id; /* Assign a component related ID to the card */
                DeviceDataPrv->Cards[Id].Initialized = TRUE; /* Mark the data structure as used */
                DeviceDataPrv->Cards[Id].Type = DeviceDataPrv->CardType;
                DeviceDataPrv->Cards[Id].CID[0] = Response[0]; /* Store the received card ID */
                DeviceDataPrv->Cards[Id].CID[1] = Response[1];
                DeviceDataPrv->Cards[Id].CID[2] = Response[2];
                DeviceDataPrv->Cards[Id].CID[3] = Response[3];
                for (Index = 0U; Index < sizeof(DeviceDataPrv->Cards[Id].Block); Index++) {
                  DeviceDataPrv->Cards[Id].Block[Index] = 0U; /* Clear the card info block */
                }
                DeviceDataPrv->Cards[Id].HighCapacity = DeviceDataPrv->HighCapacity;
                DeviceDataPrv->Cards[Id].DataWidths = LDD_SDHC_CARD_DATA_WIDTH_1_BIT; /* Initialize supported data widths */
                if (DeviceDataPrv->CardType == LDD_SDHC_SD) {
                  /* Request an RCA (relative card address) from the card */
                  SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
                } else {
                  /* Create a new RCA (relative card address) */
                  DeviceDataPrv->Cards[Id].RCA = (uint16_t)((uint16_t)Id + 2U); /* MMC RCAs must start from 2 */
                  /* Send the RCA (relative card address) to the card */
                  SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, (uint32_t)((uint32_t)Id + 2U) << 16);
                }
                SDHC_PDD_SendCommand(SDHC_BASE_PTR,
                  SDHC_PDD_CMD3_SET_RELATIVE_ADDR, SDHC_PDD_RESPONSE_LENGTH_48);
                DeviceDataPrv->Substate = SDHC1_CR_GET_RCA;
              }
            }
          } else {
            if (Error != LDD_SDHC_ERR_TIMEOUT) {
              DeviceDataPrv->LastError = Error;
            }
            /* No more card for registration */
            DeviceDataPrv->Substate = SDHC1_CR_FINISH;
            CardRegistration(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card registration state */
          }
          break;
        default:
          break;
      }
      break;
    case SDHC1_CR_GET_RCA:
      switch (DeviceDataPrv->CardType) {
        case LDD_SDHC_SD:
        case LDD_SDHC_MMC:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) && Response) {
            Id = DeviceDataPrv->NewCardId;
            if (DeviceDataPrv->CardType == LDD_SDHC_SD) {
              DeviceDataPrv->Cards[Id].RCA = SDHC1_R6_GET_RCA(Response); /* Store the received RCA (relative card address) */
            }
            SDHC1_OnCardInserted(DeviceDataPrv->UserDataPtr, Id); /* Call the user event */
          } else {
            DeviceDataPrv->LastError = Error;
          }
          DeviceDataPrv->State = LDD_SDHC_CARD_REGISTRATION;
          DeviceDataPrv->Substate = SDHC1_CR_FINISH;
          CardRegistration(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card registration state */
          break;
        default:
          break;
      }
      break;
    case SDHC1_CR_FINISH:
      switch (DeviceDataPrv->CardType) {
        case LDD_SDHC_SD:
          /* An SD card is registered, finish the voltage validation */
        case LDD_SDHC_MMC:
          /* MMC cards are checked as the last, finish the voltage validation */
          DeviceDataPrv->State = LDD_SDHC_VOLTAGE_VALIDATION;
          DeviceDataPrv->Substate = SDHC1_VV_FINISH;
          VoltageValidation(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the voltage validation state */
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

/*
** ===================================================================
**     Method      :  CardInfoRetrieval (component SDHC_LDD)
**
**     Description :
**         Card info retrieval state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void CardInfoRetrieval(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates card info retrieval end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  LDD_SDHC_TCardInfo *InfoPtr;         /* Card info pointer storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */
  uint8_t BusWidths;                   /* Supported bus widths storage */

  switch (DeviceDataPrv->Substate) {
    case SDHC1_CIR_START:
      if (DeviceDataPrv->CardState != SDHC1_STAND_BY) {
        /* Change card state to stand-by */
        DeviceDataPrv->Substate = SDHC1_CIR_STAND_BY_STATE;
        /* Send unselect card command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U); /* Set 0 as command argument to unselect card */
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD7_SELECT_CARD, SDHC_PDD_RESPONSE_LENGTH_48);
      } else {
        DeviceDataPrv->Substate = SDHC1_CIR_GET_CSD;
        CardInfoRetrieval(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card info retrieval state */
      }
      break;
    case SDHC1_CIR_STAND_BY_STATE:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error != LDD_SDHC_ERR_TIMEOUT) {
        DeviceDataPrv->LastError = Error;
      }
      DeviceDataPrv->CardState = SDHC1_STAND_BY;
      DeviceDataPrv->Substate = SDHC1_CIR_GET_CSD;
      /* Send CSD (card specific data) request command */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
        SDHC1_CMD_ARG_RCA((uint32_t)DeviceDataPrv->Cards[Id].RCA)); /* Set the card RCA (relative card address) as command argument */
      SDHC_PDD_SendCommand(SDHC_BASE_PTR,
        SDHC_PDD_CMD9_SEND_CSD, SDHC_PDD_RESPONSE_LENGTH_136);
      break;
    case SDHC1_CIR_GET_CSD:
      Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
      if ((Error == LDD_SDHC_ERR_OK) && Response) {
        /* Store the CSD (card specific data) register contained in the response */
        DeviceDataPrv->Cards[Id].CSD[0] = Response[0];
        DeviceDataPrv->Cards[Id].CSD[1] = Response[1];
        DeviceDataPrv->Cards[Id].CSD[2] = Response[2];
        DeviceDataPrv->Cards[Id].CSD[3] = Response[3];
        /* Change card state to transfer */
        DeviceDataPrv->Substate = SDHC1_CIR_TRANSFER_STATE;
        /* Send card selection command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
          SDHC1_CMD_ARG_RCA((uint32_t)DeviceDataPrv->Cards[Id].RCA)); /* Set the card RCA (relative card address) as command argument */
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD7_SELECT_CARD, SDHC_PDD_RESPONSE_LENGTH_48_BUSY_CHECK);
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC1_CIR_TRANSFER_STATE:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if ((Error == LDD_SDHC_ERR_OK) && Response) {
        if (SDHC1_R1_IS_READY_FOR_DATA(Response)) {
          DeviceDataPrv->CardState = SDHC1_TRANSFER;
          if (DeviceDataPrv->CardType == LDD_SDHC_MMC) {
            if (SDHC1_R2_MMC_GET_SPEC_VERS(Response) >= SDHC1_MMC_CSD_SPEC_VERS_4_X) {
              DeviceDataPrv->Substate = SDHC1_CIR_GET_EXT_CSD;
              DeviceDataPrv->CmdState = SDHC1_CMD_START;
            } else {
              DeviceDataPrv->Substate = SDHC1_CIR_FINISH;
            }
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->Substate = SDHC1_CIR_GET_SCR;
            DeviceDataPrv->CmdState = SDHC1_CMD_START;
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card info retrieval state */
          }
        } else {
          /* Send status request command */
          SendCardStatusRequest(DeviceDataPrv);
        }
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC1_CIR_GET_EXT_CSD:
      switch (DeviceDataPrv->CmdState) {
        case SDHC1_CMD_START:
          DeviceDataPrv->CmdState = SDHC1_CMD_FINISH;
          /* Set data transfer size */
          SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, SDHC1_EXT_CSD_SIZE);
          SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
          /* Set DMA transfer properties */
          DeviceDataPrv->TransferTable[0].Attributes = SDHC1_SINGLE_BLOCK_TRANS_ATTRS;
          DeviceDataPrv->TransferTable[0].Length = SDHC1_EXT_CSD_SIZE;
          DeviceDataPrv->TransferTable[0].Address = (uint32_t)DeviceDataPrv->Cards[Id].Block;
          SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
          /* Send extended CSD (card specific data) request command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_CMD8_SEND_EXT_CSD,
            SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_READ | SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC1_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC1_CMD_DATA;
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC1_CMD_DATA:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->Substate = SDHC1_CIR_FINISH;
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->LastError = Error;
            DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
            Finished = TRUE;
          }
          break;
        default:
          break;
      }
      break;
    case SDHC1_CIR_GET_SCR:
      switch (DeviceDataPrv->CmdState) {
        case SDHC1_CMD_START:
          DeviceDataPrv->CmdState = SDHC1_CMD_ACMD;
          /* Start application specific command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
            SDHC1_CMD_ARG_RCA((uint32_t)DeviceDataPrv->Cards[Id].RCA)); /* Set the card RCA (relative card address) as command argument */
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD55_APP_CMD, SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC1_CMD_ACMD:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC1_CMD_FINISH;
            /* Set data transfer size */
            SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, SDHC1_SCR_SIZE);
            SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
            /* Set DMA transfer properties */
            DeviceDataPrv->TransferTable[0].Attributes = SDHC1_SINGLE_BLOCK_TRANS_ATTRS;
            DeviceDataPrv->TransferTable[0].Length = SDHC1_SCR_SIZE;
            DeviceDataPrv->TransferTable[0].Address = (uint32_t)DeviceDataPrv->Cards[Id].Block;
            SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
            /* Send SCR (SD card configuration register) request command */
            SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
            SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_ACMD51_SEND_SCR,
              SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_READ | SDHC_PDD_RESPONSE_LENGTH_48);
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC1_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC1_CMD_DATA;
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC1_CMD_DATA:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            if (SDHC1_SCR_GET_SD_SPEC((uint32_t)DeviceDataPrv->Cards[Id].Block) != SDHC1_SCR_SD_SPEC_VERS_1_0X) {
              /* Check high speed support */
              DeviceDataPrv->Substate = SDHC1_CIR_GET_FUNC_STATUS;
              DeviceDataPrv->CmdState = SDHC1_CMD_START;
            } else {
              DeviceDataPrv->Substate = SDHC1_CIR_FINISH;
            }
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->LastError = Error;
            DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
            Finished = TRUE;
          }
          break;
        default:
          break;
      }
      break;
    case SDHC1_CIR_GET_FUNC_STATUS:
      switch (DeviceDataPrv->CmdState) {
        case SDHC1_CMD_START:
          DeviceDataPrv->CmdState = SDHC1_CMD_FINISH;
          /* Set data transfer size */
          SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, SDHC1_SFS_SIZE);
          SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
          /* Set DMA transfer properties */
          DeviceDataPrv->TransferTable[0].Attributes = SDHC1_SINGLE_BLOCK_TRANS_ATTRS;
          DeviceDataPrv->TransferTable[0].Length = SDHC1_SFS_SIZE;
          DeviceDataPrv->TransferTable[0].Address = (uint32_t)&DeviceDataPrv->Cards[Id].Block[SDHC1_SFS_BLOCK_START];
          SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
          /* Send function check command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
            SDHC1_SD_CMD6_ARG_MODE(SDHC1_SD_CMD6_CHECK_FUNC) |
            SDHC1_SD_CMD6_ARG_GROUP_1(SDHC1_SD_CMD6_GROUP_1_HIGH_SPEED));
          SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_CMD6_SWITCH,
            SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_READ | SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC1_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC1_CMD_DATA;
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC1_CMD_DATA:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->Substate = SDHC1_CIR_FINISH;
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC1_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->LastError = Error;
            DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
            Finished = TRUE;
          }
          break;
        default:
          break;
      }
      break;
    case SDHC1_CIR_FINISH:
      Response = DeviceDataPrv->Cards[Id].CSD; /* Get a pointer to card specific data */
      InfoPtr = DeviceDataPrv->CardInfoPtr; /* Get a pointer to the user card info variable */
      InfoPtr->Type = DeviceDataPrv->CardType; /* Get card type from selected card type */
      /* Extract card information from card registers */
      InfoPtr->BlockLength = (uint16_t)((uint16_t)1U << SDHC1_R2_GET_READ_BL_LEN(Response)); /* Block length = 2^READ_BL_LEN */
      if ((DeviceDataPrv->CardType != LDD_SDHC_SD) || (SDHC1_R2_GET_CSD_STRUCTURE(Response) == SDHC1_SD_CSD_VERS_1_0)) {
        /* CSD (card specific data) version 1.0 */
        /* Block count = (C_SIZE + 1) * (2^(C_SIZE_MULT + 2)) */
        InfoPtr->BlockCount = (uint16_t)(SDHC1_R2_CSD_V1_GET_C_SIZE(Response) + 1U) *
          (uint16_t)((uint16_t)1U << (SDHC1_R2_CSD_V1_GET_C_SIZE_MULT(Response) + 2U));
      } else {
        /* CSD (card specific data) version 2.0 */
        /* Block count = (C_SIZE + 1) * 1k */
        InfoPtr->BlockCount = (SDHC1_R2_CSD_V2_GET_C_SIZE(Response) + 1U) * 1024U;
      }
      InfoPtr->Caps.Operations = (uint8_t)(SDHC1_R2_GET_CCC(Response) >> 2); /* Shift card command classes to fit into a byte (omitting mandatory classes) */
      InfoPtr->Caps.HighCapacity = DeviceDataPrv->Cards[Id].HighCapacity; /* Get high capacity flag acquired during voltage validation */
      InfoPtr->Caps.LowVoltage = (DeviceDataPrv->CardsVoltages & SDHC1_OCR_LOW_VOLTAGE_MASK) ? TRUE : FALSE; /* Get low voltage support flag acquired during voltage validation */
      InfoPtr->Caps.Read.MaxBlockLength = (uint16_t)((uint16_t)1U << SDHC1_R2_GET_READ_BL_LEN(Response)); /* Max. read block length = 2^READ_BL_LEN */
      InfoPtr->Caps.Read.MisalignBlock = (SDHC1_R2_GET_READ_BLK_MISALIGN(Response)) ? TRUE : FALSE;
      InfoPtr->Caps.Read.PartialBlock = (SDHC1_R2_GET_READ_BL_PARTIAL(Response)) ? TRUE : FALSE;
      InfoPtr->Caps.Write.MaxBlockLength = (uint16_t)((uint16_t)1U << SDHC1_R2_GET_WRITE_BL_LEN(Response)); /* Max. write block length = 2^WRITE_BL_LEN */
      InfoPtr->Caps.Write.MisalignBlock = (SDHC1_R2_GET_WRITE_BLK_MISALIGN(Response)) ? TRUE : FALSE;
      InfoPtr->Caps.Write.PartialBlock = (SDHC1_R2_GET_WRITE_BL_PARTIAL(Response)) ? TRUE : FALSE;
      InfoPtr->Caps.WriteProtect.Permanent = (SDHC1_R2_GET_PERM_WRITE_PROTECT(Response)) ? TRUE : FALSE;
      if (DeviceDataPrv->CardType == LDD_SDHC_MMC) {
        InfoPtr->Caps.DataWidths = DeviceDataPrv->Cards[Id].DataWidths; /* Get data widths acquired during bus testing procedure */
        InfoPtr->Caps.HighSpeed = (SDHC1_R2_MMC_GET_SPEC_VERS(Response) == SDHC1_MMC_CSD_SPEC_VERS_4_X) ? TRUE : FALSE; /* High speed supported by MMC cards from version 4.0 */
        /* Erase sector size = (ERASE_GRP_SIZE + 1) * (ERASE_GRP_MULT + 1) */
        InfoPtr->Caps.Erase.SectorSize = (uint16_t)((SDHC1_R2_MMC_GET_ERASE_GRP_SIZE(Response) + 1U) *
          (SDHC1_R2_MMC_GET_ERASE_GRP_MULT(Response) + 1U));
        /* Get erased memory byte content from the extended CSD (card specific data) register */
        InfoPtr->Caps.Erase.Pattern = DeviceDataPrv->Cards[Id].Block[SDHC1_EXT_CSD_ERASED_MEM_CONT_INDEX];
        /* Write protection group size = WP_GRP_SIZE + 1 */
        InfoPtr->Caps.WriteProtect.GroupSize = (uint16_t)((SDHC1_R2_GET_WP_GRP_ENABLE(Response)) ?
          (SDHC1_R2_MMC_GET_WP_GRP_SIZE(Response) + 1U) : 0U);
      } else {
        BusWidths = (uint8_t)SDHC1_SCR_GET_SD_BUS_WIDTHS((uint32_t)DeviceDataPrv->Cards[Id].Block);
        InfoPtr->Caps.DataWidths = (uint8_t) /* Map SCR (SD card configuration register) values to component constants */
          (((BusWidths & SDHC1_SCR_SD_BUS_WIDTH_1_BIT_MASK) ? LDD_SDHC_CARD_DATA_WIDTH_1_BIT : 0U) |
          ((BusWidths & SDHC1_SCR_SD_BUS_WIDTH_4_BIT_MASK) ? LDD_SDHC_CARD_DATA_WIDTH_4_BIT : 0U));
        if (SDHC1_SCR_GET_SD_SPEC((uint32_t)DeviceDataPrv->Cards[Id].Block) == SDHC1_SCR_SD_SPEC_VERS_1_0X) {
          /* High speed is not supported in this version of SD card specification */
          InfoPtr->Caps.HighSpeed = FALSE;
        } else {
          /* Get high speed support flag acquired during high speed function check */
          InfoPtr->Caps.HighSpeed = (SDHC1_SFS_IS_FUNC_SUPPORTED(
            (uint32_t)&DeviceDataPrv->Cards[Id].Block[SDHC1_SFS_BLOCK_START],
            SDHC1_SFS_HIGH_SPEED_FUNC_GROUP, SDHC1_SFS_HIGH_SPEED_FUNC_INDEX)) ? TRUE : FALSE;
        }
        InfoPtr->Caps.Erase.SectorSize = (uint16_t)(SDHC1_R2_SD_GET_SECTOR_SIZE(Response) + 1U);
        InfoPtr->Caps.Erase.Pattern = (uint8_t) /* Erase memory byte content is defined by a data status flag */
          ((SDHC1_SCR_GET_DATA_STAT_AFTER_ERASE((uint32_t)DeviceDataPrv->Cards[Id].Block)) ? 0xFFU : 0x00U);
        if (SDHC1_R2_GET_CSD_STRUCTURE(Response) == SDHC1_SD_CSD_VERS_2_0) {
          /* CSD (card specific data) structure version 2.0 */
          InfoPtr->Caps.WriteProtect.GroupSize = (uint16_t)0U;
        } else {
          /* CSD (card specific data) structure version 1.0 */
          InfoPtr->Caps.WriteProtect.GroupSize = (uint16_t)((SDHC1_R2_GET_WP_GRP_ENABLE(Response)) ?
            (SDHC1_R2_SD_GET_WP_GRP_SIZE(Response) + 1U) : 0U);
        }
      }
      Finished = TRUE;
      break;
    default:
      break;
  }
  if (Finished) {
    DeviceDataPrv->State = LDD_SDHC_IDLE;
    SDHC1_OnFinished(DeviceDataPrv->UserDataPtr); /* Call the user event */
  }
}

/*
** ===================================================================
**     Method      :  CardSelection (component SDHC_LDD)
**
**     Description :
**         Card selection state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool CardSelection(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates card selection end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */

  Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
  if ((Error == LDD_SDHC_ERR_OK) && Response) {
    if (SDHC1_R1_IS_READY_FOR_DATA(Response)) {
      /* By card selection card has changed its state to transfer */
      DeviceDataPrv->CardState = SDHC1_TRANSFER;
      Finished = TRUE;
    } else {
      /* Send status request command again */
      SendCardStatusRequest(DeviceDataPrv);
    }
  } else {
    if (Id != SDHC1_NO_CARD) {
      DeviceDataPrv->LastError = Error;
      DeviceDataPrv->Cards[Id].Initialized = FALSE;
      DeviceDataPrv->CardId = SDHC1_NO_CARD; /* Card has been removed */
      SDHC1_OnCardRemoved(DeviceDataPrv->UserDataPtr, Id); /* Call the user event */
    } else {
      if (Error != LDD_SDHC_ERR_TIMEOUT) {
        DeviceDataPrv->LastError = Error;
      }
    }
    Finished = TRUE;
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  Transfer (component SDHC_LDD)
**
**     Description :
**         Transfer state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool Transfer(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates transfer end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */

  switch (DeviceDataPrv->CmdState) {
    case SDHC1_CMD_DATA_LEN:
      DeviceDataPrv->CmdState = SDHC1_CMD_START;
      /* Send block length */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, DeviceDataPrv->TransferBlockSize);
      SDHC_PDD_SendCommand(SDHC_BASE_PTR,
        SDHC_PDD_CMD16_SET_BLOCKLEN, SDHC_PDD_RESPONSE_LENGTH_48);
      break;
    case SDHC1_CMD_START:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error == LDD_SDHC_ERR_OK) {
        DeviceDataPrv->CmdState = SDHC1_CMD_FINISH;
        SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
        /* Set block attributes */
        SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, DeviceDataPrv->TransferBlockSize);
        SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, DeviceDataPrv->TransferBlockCount);
        /* Send transfer command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, DeviceDataPrv->Address);
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          ((DeviceDataPrv->TransferOperation == LDD_SDHC_READ) ?
            (uint32_t)((DeviceDataPrv->TransferBlockCount > 1U) ?
              SDHC_PDD_CMD18_READ_MULTIPLE_BLOCK : SDHC_PDD_CMD17_READ_SINGLE_BLOCK) :
            (uint32_t)((DeviceDataPrv->TransferBlockCount > 1U) ?
              SDHC_PDD_CMD25_WRITE_MULTIPLE_BLOCK : SDHC_PDD_CMD24_WRITE_BLOCK)),
          ((DeviceDataPrv->TransferBlockCount > 1U) ?
            (SDHC_PDD_ENABLE_BLOCK_COUNT | SDHC_PDD_ENABLE_AUTO_CMD12 | SDHC_PDD_MULTIPLE_BLOCK) : 0U) |
          SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_RESPONSE_LENGTH_48 |
          ((DeviceDataPrv->TransferOperation == LDD_SDHC_READ) ?
            SDHC_PDD_DATA_READ : SDHC_PDD_DATA_WRITE));
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC1_CMD_FINISH:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error == LDD_SDHC_ERR_OK) {
        DeviceDataPrv->CmdState = SDHC1_CMD_DATA;
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC1_CMD_DATA:
      Error = GetCommandError(DeviceDataPrv, Flags, SDHC1_NO_RESPONSE); /* Check host error flags */
      if (Error != LDD_SDHC_ERR_OK) {
        DeviceDataPrv->LastError = Error;
        DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
      }
      DeviceDataPrv->CmdState = SDHC1_CMD_ERROR;
      SendCardStatusRequest(DeviceDataPrv);
      break;
    case SDHC1_CMD_ERROR:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if ((Error == LDD_SDHC_ERR_OK) && Response) {
        if (SDHC1_R1_IS_READY_FOR_DATA(Response)) {
          Finished = TRUE;
        } else {
          /* Send status request command again */
          SendCardStatusRequest(DeviceDataPrv);
        }
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    default:
      break;
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  GetCommandError (component SDHC_LDD)
**
**     Description :
**         Extracts error code from the device error flags and the card 
**         status response.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_SDHC_TError GetCommandError(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint32_t AutoCMD12ErrorFlags = SDHC_PDD_GetAutoCMD12ErrorFlags(SDHC_BASE_PTR); /* Auto CMD12 error flags */

  (void)DeviceDataPtr;                 /* Suppress unused parameter warning */
  /* Map host error flags to component error codes */
  if ((Flags & (SDHC_PDD_COMMAND_TIMEOUT_ERROR_INT | SDHC_PDD_DATA_TIMEOUT_ERROR_INT)) ||
      ((Flags & SDHC_PDD_AUTO_CMD12_ERROR_INT) && (AutoCMD12ErrorFlags & SDHC_PDD_AUTO_CMD12_TIMEOUT_ERROR))) {
    Error = LDD_SDHC_ERR_TIMEOUT;
  } else if ((Flags & (SDHC_PDD_COMMAND_CRC_ERROR_INT | SDHC_PDD_COMMAND_END_BIT_ERROR_INT |
      SDHC_PDD_COMMAND_INDEX_ERROR_INT)) || ((Flags & SDHC_PDD_AUTO_CMD12_ERROR_INT) &&
      (AutoCMD12ErrorFlags & (SDHC_PDD_AUTO_CMD12_CRC_ERROR | SDHC_PDD_AUTO_CMD12_END_BIT_ERROR | SDHC_PDD_AUTO_CMD12_INDEX_ERROR)))) {
    Error = LDD_SDHC_ERR_COMMAND_CRC;
  } else if (Flags & (SDHC_PDD_DATA_CRC_ERROR_INT | SDHC_PDD_DATA_END_BIT_ERROR_INT)) {
    Error = LDD_SDHC_ERR_DATA_CRC;
  } else if (Flags & SDHC_PDD_DMA_ERROR_INT) {
    Error = LDD_SDHC_ERR_DMA;
  } else {
    Error = LDD_SDHC_ERR_OK;
  }
  if ((Error == LDD_SDHC_ERR_OK) && Response) {
    /* Map card error flags to component error codes */
    if (SDHC1_R1_IS_ERASE_RESET(Response) ||
        SDHC1_R1_IS_CSD_OVERWRITE(Response) ||
        SDHC1_R1_IS_ERASE_SEQ_ERROR(Response) ||
        SDHC1_R1_IS_ILLEGAL_COMMAND(Response)) {
      Error = LDD_SDHC_ERR_INTERNAL_FAILURE;
    } else if (SDHC1_R1_IS_WP_ERASE_SKIP(Response)) {
      Error = LDD_SDHC_ERR_WP_ERASE_SKIP;
    } else if (SDHC1_R1_MMC_IS_OVERRUN(Response) ||
        SDHC1_R1_MMC_IS_UNDERRUN(Response) ||
        SDHC1_R1_IS_ERROR(Response) ||
        SDHC1_R1_IS_CC_ERROR(Response) ||
        SDHC1_R1_IS_CARD_ECC_FAILED(Response)) {
      Error = LDD_SDHC_ERR_CARD_FAILURE;
    } else if (SDHC1_R1_IS_COM_CRC_ERROR(Response)) {
      Error = LDD_SDHC_ERR_COMMAND_CRC;
    } else if (SDHC1_R1_IS_CARD_IS_LOCKED(Response)) {
      Error = LDD_SDHC_ERR_CARD_IS_LOCKED;
    } else if (SDHC1_R1_IS_WP_VIOLATION(Response)) {
      Error = LDD_SDHC_ERR_WP_VIOLATION;
    } else if (SDHC1_R1_IS_ERASE_PARAM(Response) ||
        SDHC1_R1_IS_ADDRESS_MISALIGN(Response)) {
      Error = LDD_SDHC_ERR_ADDRESS_MISALIGN;
    } else if (SDHC1_R1_IS_BLOCK_LEN_ERROR(Response)) {
      Error = LDD_SDHC_ERR_BLOCK_LEN_ERROR;
    } else if (SDHC1_R1_IS_ADDRESS_OUT_OF_RANGE(Response)) {
      Error = LDD_SDHC_ERR_ADDRESS_OUT_OF_RANGE;
    } else {
      Error = LDD_SDHC_ERR_OK;
    }
  }
  return Error;
}

/*
** ===================================================================
**     Method      :  SendCardStatusRequest (component SDHC_LDD)
**
**     Description :
**         Sends a card status request.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void SendCardStatusRequest(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */

  /* Send status request command */
  SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
    SDHC1_CMD_ARG_RCA(DeviceDataPrv->Cards[Id].RCA));
  SDHC_PDD_SendCommand(SDHC_BASE_PTR,
    SDHC_PDD_CMD13_SEND_STATUS, SDHC_PDD_RESPONSE_LENGTH_48);
}

/*
** ===================================================================
**     Method      :  SDHC1_Interrupt (component SDHC_LDD)
**
**     Description :
**         The method services the interrupt of the selected peripheral(s)
**         and eventually invokes event(s) of the component.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(SDHC1_Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  SDHC1_TDeviceData* DeviceDataPrv = INT_SDHC__DEFAULT_RTOS_ISRPARAM;

  EventHandler(DeviceDataPrv);
}

/*
** ===================================================================
**     Method      :  EventHandler (component SDHC_LDD)
**
**     Description :
**         Hardware event handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void EventHandler(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC1_TDeviceData *DeviceDataPrv = (SDHC1_TDeviceData*)DeviceDataPtr;
  uint32_t IntFlags = SDHC_PDD_GetInterruptFlags(SDHC_BASE_PTR); /* Store interrupt flags */
  const uint32_t CompletionFlags = SDHC_PDD_COMMAND_COMPLETE_INT |
    SDHC_PDD_TRANSFER_COMPLETE_INT | SDHC_PDD_BUFFER_READ_READY_INT |
    SDHC_PDD_BUFFER_WRITE_READY_INT;
  const uint32_t CommandErrorFlags = SDHC_PDD_COMMAND_TIMEOUT_ERROR_INT | /* Command error interrupt flags mask */
    SDHC_PDD_COMMAND_CRC_ERROR_INT | SDHC_PDD_COMMAND_INDEX_ERROR_INT |
    SDHC_PDD_AUTO_CMD12_ERROR_INT;
  const uint32_t DataErrorFlags = SDHC_PDD_DATA_TIMEOUT_ERROR_INT | /* Data transfer error interrupt flags mask */
    SDHC_PDD_DATA_CRC_ERROR_INT | SDHC_PDD_DATA_END_BIT_ERROR_INT |
    SDHC_PDD_DMA_ERROR_INT;
  const uint32_t ErrorFlags = CommandErrorFlags | DataErrorFlags; /* Error interrupt flags mask */
  bool Finished = FALSE;               /* Indicates operation end */
  uint32_t Buffer[4];                  /* Response buffer */
  uint32_t *Response = SDHC1_NO_RESPONSE; /* Response buffer pointer */

  if (IntFlags & (CompletionFlags | ErrorFlags)) {
    if (IntFlags & SDHC_PDD_COMMAND_COMPLETE_INT) {
      SDHC_PDD_ClearInterruptFlags(SDHC_BASE_PTR, SDHC_PDD_COMMAND_COMPLETE_INT);
      /* Check command completion errors */
      if (IntFlags & CommandErrorFlags) {
        SDHC_PDD_ClearInterruptFlags(SDHC_BASE_PTR, CommandErrorFlags);
        Response = SDHC1_NO_RESPONSE;  /* No valid response has been received */
      } else {
        SDHC_PDD_GetCommandResponse(SDHC_BASE_PTR, Buffer);
        Response = Buffer;             /* Assign the response pointer */
      }
    } else {
      if (IntFlags & SDHC_PDD_TRANSFER_COMPLETE_INT) {
        SDHC_PDD_ClearInterruptFlags(SDHC_BASE_PTR, SDHC_PDD_TRANSFER_COMPLETE_INT | DataErrorFlags);
      }
    }
    switch (DeviceDataPrv->State) {
      case LDD_SDHC_RESET:
        Finished = TRUE;
        break;
      case LDD_SDHC_VOLTAGE_VALIDATION:
        VoltageValidation(DeviceDataPrv, IntFlags, Response); /* Handle the voltage validation state */
        break;
      case LDD_SDHC_CARD_REGISTRATION:
        CardRegistration(DeviceDataPrv, IntFlags, Response); /* Handle the card registration state */
        break;
      case LDD_SDHC_CARD_INFO_RETRIEVAL:
        CardInfoRetrieval(DeviceDataPrv, IntFlags, Response); /* Handle the card info retrieval state */
        break;
      case LDD_SDHC_CARD_SELECTION:
        Finished = CardSelection(DeviceDataPrv, IntFlags, Response); /* Handle the card selection state */
        break;
      case LDD_SDHC_TRANSFER:
        Finished = Transfer(DeviceDataPrv, IntFlags, Response); /* Handle the transfer state */
        break;
      default:
        break;
    }
  }
  if (Finished) {
    DeviceDataPrv->State = LDD_SDHC_IDLE;
    SDHC1_OnFinished(DeviceDataPrv->UserDataPtr); /* Call the user event */
  }
}

/*lint -restore  +esym(960,10.1) Enable MISRA rule (10.1,12.1) checking. */

/* END SDHC1 */

#ifdef __cplusplus
}  /* extern "C" */
#endif 

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
