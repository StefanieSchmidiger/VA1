/*
 / _____)             _              | |
 ( (____  _____ ____ _| |_ _____  ____| |__
 \____ \| ___ |    (_   _) ___ |/ ___)  _ \
 _____) ) ____| | | || |_| ____( (___| | | |
 (______/|_____)_|_|_| \__)_____)\____)_| |_|
 (C)2013 Semtech

 Description: LoRaMac classA device implementation

 License: Revised BSD License, see LICENSE.TXT file include in the project

 Maintainer: Miguel Luis and Gregory Cristian
 */
#include <string.h>
#include <math.h>
#include "board.h"

#include "LoRaMac.h"

/*!
 * When set to 1 the application uses the Over-the-Air activation procedure
 * When set to 0 the application uses the Personalization activation procedure
 */
#define OVER_THE_AIR_ACTIVATION                     0

/*!
 * Indicates if the end-device is to be connected to a private or public network
 */
#define LORAWAN_PUBLIC_NETWORK                      true

#if( OVER_THE_AIR_ACTIVATION != 0 )

/*!
 * Join requests trials duty cycle.
 */
#define OVER_THE_AIR_ACTIVATION_DUTYCYCLE           10000000  // 10 [s] value in us

/*!
 * Mote device IEEE EUI
 *
 * \remark must be written as a little endian value (reverse order of normal reading)
 *
 * \remark In this application the value is automatically generated by calling
 *         BoardGetUniqueId function
 */
#define LORAWAN_DEVICE_EUI                          { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }

/*!
 * Application IEEE EUI
 *
 * \remark must be written as a little endian value (reverse order of normal reading)
 */
#define LORAWAN_APPLICATION_EUI                     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }

/*!
 * AES encryption/decryption cipher application key
 */
#define LORAWAN_APPLICATION_KEY                     { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00 }

#else

/*!
 * Current network ID
 */
#define LORAWAN_NETWORK_ID                          ( uint32_t )0

/*!
 * Device address on the network
 *
 * \remark must be written as a big endian value (normal reading order)
 *
 * \remark In this application the value is automatically generated using
 *         a pseudo random generator seeded with a value derived from
 *         BoardUniqueId value
 */
#define LORAWAN_DEVICE_ADDRESS                      ( uint32_t )0x00000000

/*!
 * AES encryption/decryption cipher network session key
 */
#define LORAWAN_NWKSKEY                             { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C }

/*!
 * AES encryption/decryption cipher application session key
 */
#define LORAWAN_APPSKEY                             { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C }

#endif

/*!
 * Defines the application data transmission duty cycle
 */
#define APP_TX_DUTYCYCLE                            1000000  // 5 [s] value in us
#define APP_TX_DUTYCYCLE_RND                        1000000  // 1 [s] value in us

/*!
 * LoRaWAN confirmed messages
 */
#define LORAWAN_CONFIRMED_MSG_ON                    false

/*!
 * LoRaWAN Adaptative Data Rate
 *
 * \remark Please note that when ADR is enabled the end-device should be static
 */
#define LORAWAN_ADR_ON                              0

/*!
 * LoRaWAN ETSI duty cycle control enable/disable
 *
 * \remark Please note that ETSI mandates duty cycled transmissions. Use only for test purposes
 */
#define LORAWAN_DUTYCYCLE_ON                        false

/*!
 * LoRaWAN application port
 */
#define LORAWAN_APP_PORT                            2

/*!
 * User application data buffer size
 */
#define LORAWAN_APP_DATA_SIZE                       12

#if( OVER_THE_AIR_ACTIVATION != 0 )

static uint8_t DevEui[] = LORAWAN_DEVICE_EUI;
static uint8_t AppEui[] = LORAWAN_APPLICATION_EUI;
static uint8_t AppKey[] = LORAWAN_APPLICATION_KEY;

#else

static uint8_t NwkSKey[] = LORAWAN_NWKSKEY;
static uint8_t AppSKey[] = LORAWAN_APPSKEY;

/*!
 * Device address
 */
static uint32_t DevAddr;

#endif

/*!
 * Indicates if the MAC layer has already joined a network.
 */
static bool IsNetworkJoined = false;

/*!
 * Application port
 */
static uint8_t AppPort = LORAWAN_APP_PORT;

/*!
 * User application data size
 */
static uint8_t AppDataSize = LORAWAN_APP_DATA_SIZE;

/*!
 * User application data buffer size
 */
#define LORAWAN_APP_DATA_MAX_SIZE                           64

/*!
 * User application data
 */
static uint8_t AppData[LORAWAN_APP_DATA_MAX_SIZE];

/*!
 * Indicates if the node is sending confirmed or unconfirmed messages
 */
static uint8_t IsTxConfirmed = LORAWAN_CONFIRMED_MSG_ON;

/*!
 * Defines the application data transmission duty cycle
 */
static uint32_t TxDutyCycleTime;

static TimerEvent_t TxNextPacketTimer;

#if( OVER_THE_AIR_ACTIVATION != 0 )

/*!
 * Defines the join request timer
 */
static TimerEvent_t JoinReqTimer;

#endif

/*!
 * Indicates if a new packet can be sent
 */
static bool TxNextPacket = true;
static bool ScheduleNextTx = false;
static bool DownlinkStatusUpdate = false;

static LoRaMacCallbacks_t LoRaMacCallbacks;

static bool AppLedStateOn = false;
static bool AppLedStateChanged = false;
static bool AppSensorTransmissionStateOn = true;
static bool AppSensorTransmissionStateChanged = false;
static bool NewSensorDataReceived = false;

static accel_sensor_data_t SensorData;

bool SwitchAPushEvent = false;
bool SwitchBPushEvent = false;

/*!
 * \brief Switch A IRQ callback
 */
void SwitchAIrq( void );

/*!
 * \brief Switch B IRQ callback
 */
void SwitchBIrq( void );

/*!
 * Prepares the frame buffer to be sent
 */
static void PrepareTxFrame( uint8_t port )
{
    switch (port) {
        case 2:
        {
            AppData[0] = 'H';
            AppData[1] = 'e';
            AppData[2] = 'l';
            AppData[3] = 'l';
            AppData[4] = 'o';
            AppData[5] = ' ';
            AppData[6] = 'W';
            AppData[7] = 'o';
            AppData[8] = 'r';
            AppData[9] = 'l';
            AppData[10] = 'd';
            AppData[11] = '\0';
        }
            break;
        default:
            break;
    }
}

static void ProcessRxFrame( LoRaMacEventFlags_t *flags, LoRaMacEventInfo_t *info )
{
    switch (info->RxPort) // Check Rx port number
    {
        case 1: // The application LED can be controlled on port 1 or 2
        case 2:
            if ( info->RxBufferSize == 15 ) {
                AppLedStateOn = ((info->RxBuffer[0] & 0x01) == 0 ? false : true);
                AppSensorTransmissionStateOn = ((info->RxBuffer[1] & 0x01) == 0 ? false : true);

                SensorData.accelX = (uint16_t)((info->RxBuffer[2] << 8) | info->RxBuffer[3]);
                SensorData.accelY = (uint16_t)((info->RxBuffer[4] << 8) | info->RxBuffer[5]);
                SensorData.accelZ = (uint16_t)((info->RxBuffer[6] << 8) | info->RxBuffer[7]);

                SensorData.magX = (uint16_t)((info->RxBuffer[9] << 8) | info->RxBuffer[10]);
                SensorData.magY = (uint16_t)((info->RxBuffer[11] << 8) | info->RxBuffer[12]);
                SensorData.magZ = (uint16_t)((info->RxBuffer[13] << 8) | info->RxBuffer[14]);

                NewSensorDataReceived = true;
            }
            break;
        default:
            break;
    }
}

static bool SendFrame( void )
{
    uint8_t sendFrameStatus = 0;

    if ( IsTxConfirmed == false ) {
        sendFrameStatus = LoRaMacSendFrame(AppPort, AppData, AppDataSize);
    } else {
        sendFrameStatus = LoRaMacSendConfirmedFrame(AppPort, AppData, AppDataSize, 8);
    }

    switch (sendFrameStatus) {
        case 5: // NO_FREE_CHANNEL
            // Try again later
            return true;
        default:
            return false;
    }
}

#if( OVER_THE_AIR_ACTIVATION != 0 )

/*!
 * \brief Function executed on JoinReq Timeout event
 */
static void OnJoinReqTimerEvent( void )
{
    TimerStop( &JoinReqTimer );
    TxNextPacket = true;
}

#endif

/*!
 * \brief Function to be executed on MAC layer event
 */
static void OnMacEvent( LoRaMacEventFlags_t *flags, LoRaMacEventInfo_t *info )
{
    if ( flags->Bits.JoinAccept == 1 ) {
#if( OVER_THE_AIR_ACTIVATION != 0 )
        TimerStop( &JoinReqTimer );
#endif
        IsNetworkJoined = true;
    } else {
        if ( flags->Bits.Tx == 1 ) {
        }

        if ( flags->Bits.Rx == 1 ) {
            if ( flags->Bits.RxData == true ) {
                ProcessRxFrame(flags, info);
            }

            DownlinkStatusUpdate = true;
        }
    }
    // Schedule a new transmission
    ScheduleNextTx = true;
}

/*!
 * \brief Function executed on TxNextPacket Timeout event
 */
static void OnTxNextPacketTimerEvent( void )
{
    TimerStop(&TxNextPacketTimer);
    TxNextPacket = true;
}

/**
 * Main application entry point.
 */
int main( void )
{
#if( OVER_THE_AIR_ACTIVATION != 0 )
    uint8_t sendFrameStatus = 0;
#endif
    bool trySendingFrameAgain = false;

    BoardInitMcu();
    PRINTF("DEBUG: Mcu initialized.\r\n");
    BoardInitPeriph();
    PRINTF("DEBUG: Peripherals initialized.\r\n");

    /* Switch A & B */
    GpioSetInterrupt(&SwitchA, IRQ_FALLING_EDGE, IRQ_LOW_PRIORITY, SwitchAIrq);
    GpioSetInterrupt(&SwitchB, IRQ_FALLING_EDGE, IRQ_LOW_PRIORITY, SwitchBIrq);

    LoRaMacCallbacks.MacEvent = OnMacEvent;
    LoRaMacCallbacks.GetBatteryLevel = BoardGetBatteryLevel;
    LoRaMacInit(&LoRaMacCallbacks);
    PRINTF("DEBUG: LoRaMac initialized.\r\n");

    AppLedStateChanged = true;
    AppSensorTransmissionStateChanged = true;
    IsNetworkJoined = false;

#if( OVER_THE_AIR_ACTIVATION == 0 )
    // Random seed initialization
    srand1 (BoardGetRandomSeed() );
    // Choose a random device address based on Board unique ID
    // NwkAddr rand [0, 33554431]
DevAddr    = randr(0, 0x01FFFFFF);

    LoRaMacInitNwkIds( LORAWAN_NETWORK_ID, DevAddr, NwkSKey, AppSKey);
    IsNetworkJoined = true;
#else
    // Initialize LoRaMac device unique ID
    BoardGetUniqueId( DevEui );

    // Sends a JoinReq Command every OVER_THE_AIR_ACTIVATION_DUTYCYCLE
    // seconds until the network is joined
    TimerInit( &JoinReqTimer, OnJoinReqTimerEvent );
    TimerSetValue( &JoinReqTimer, OVER_THE_AIR_ACTIVATION_DUTYCYCLE );
#endif

    TxNextPacket = true;
    TimerInit(&TxNextPacketTimer, OnTxNextPacketTimerEvent);

    LoRaMacSetAdrOn( LORAWAN_ADR_ON);
    LoRaMacTestSetDutyCycleOn( LORAWAN_DUTYCYCLE_ON);
    LoRaMacTestSetMic(1u);
    LoRaMacSetPublicNetwork( LORAWAN_PUBLIC_NETWORK);

    while (1) {
        while (IsNetworkJoined == false) {
#if( OVER_THE_AIR_ACTIVATION != 0 )
            if( TxNextPacket == true )
            {
                TxNextPacket = false;

                sendFrameStatus = LoRaMacJoinReq( DevEui, AppEui, AppKey );
                switch( sendFrameStatus )
                {
                    case 1: // BUSY
                    break;
                    case 0:// OK
                    case 2:// NO_NETWORK_JOINED
                    case 3:// LENGTH_PORT_ERROR
                    case 4:// MAC_CMD_ERROR
                    case 6:// DEVICE_OFF
                    default:
                    // Relaunch timer for next trial
                    TimerStart( &JoinReqTimer );
                    break;
                }
            }
            TimerLowPowerHandler( );
#endif
        }

        if ( SwitchAPushEvent ) {
            DelayMs(20);    // Software debouncing
            SwitchAPushEvent = false;
            if ( AppLedStateOn ) PRINTF("TRACE: Remotely disable LED.\r\n");
            else PRINTF("TRACE: Remotely enable LED.\r\n");
            AppLedStateOn = !AppLedStateOn;
            AppLedStateChanged = true;
        }

        if ( SwitchBPushEvent ) {
            DelayMs(20);    // Software debouncing
            SwitchBPushEvent = false;
            if ( AppSensorTransmissionStateOn ) PRINTF(
                    "TRACE: Remotely disable sensor data collecting.\r\n");
            else PRINTF("TRACE: Remotely enable sensor data collecting.\r\n");
            AppSensorTransmissionStateOn = !AppSensorTransmissionStateOn;
            AppSensorTransmissionStateChanged = true;
        }

        if ( DownlinkStatusUpdate == true ) {
            DownlinkStatusUpdate = false;
        }

        if ( NewSensorDataReceived ) {
            NewSensorDataReceived = false;
            PRINTF("DATA: Accelerometer (x/y/z) \t%d \t%d \t%d\r\n", SensorData.accelX,
                    SensorData.accelY, SensorData.accelZ);
            PRINTF("DATA: Magnetometer (x/y/z) \t%d \t%d \t%d\r\n", SensorData.magX,
                    SensorData.magY, SensorData.magZ);
        }

        if ( ScheduleNextTx && AppSensorTransmissionStateOn ) {
            PRINTF("TRACE: Schedule next uplink packet.\r\n");
            ScheduleNextTx = false;

            // Schedule next packet transmission
            TxDutyCycleTime = APP_TX_DUTYCYCLE + randr(-APP_TX_DUTYCYCLE_RND, APP_TX_DUTYCYCLE_RND);
            TimerSetValue(&TxNextPacketTimer, TxDutyCycleTime);
            TimerStart(&TxNextPacketTimer);
        }

        if ( trySendingFrameAgain == true ) {
            PRINTF("TRACE: Re-sending frame...\r\n");
            trySendingFrameAgain = SendFrame();
            if ( trySendingFrameAgain ) PRINTF("TRACE: No free channel. Try again later.\r\n");
        }

        if ( TxNextPacket ) {
            PRINTF("TRACE: Trying to send frame...\r\n");
            TxNextPacket = false;
            if ( AppSensorTransmissionStateChanged ) AppSensorTransmissionStateChanged = false;
            if ( AppLedStateChanged ) AppLedStateChanged = false;

            PrepareTxFrame(AppPort);

            trySendingFrameAgain = SendFrame();

            if ( trySendingFrameAgain ) PRINTF("TRACE: No free channel. Try again later.\r\n");
        }

        TimerLowPowerHandler();
    }
}

void SwitchAIrq( void )
{
    SwitchAPushEvent = true;
}

void SwitchBIrq( void )
{
    SwitchBPushEvent = true;
}
